"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["1587"],{76894:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>i,default:()=>h,contentTitle:()=>r,assets:()=>l,toc:()=>c,metadata:()=>o});var o=JSON.parse('{"id":"concepts/node-replacement","title":"Node Replacement","description":"Node Replacement allow you to replace all instances of a given node in your editor with instances of a subclass.","source":"@site/docs/concepts/node-replacement.md","sourceDirName":"concepts","slug":"/concepts/node-replacement","permalink":"/docs/concepts/node-replacement","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/node-replacement.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Nodes","permalink":"/docs/concepts/nodes"},"next":{"title":"NodeState","permalink":"/docs/concepts/node-state"}}'),a=n(52322),s=n(22840);let i={},r="Node Replacement",l={},c=[{value:"Use Case",id:"use-case",level:2},{value:"Node Replacement Example",id:"node-replacement-example",level:2}];function d(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"node-replacement",children:"Node Replacement"})}),"\n",(0,a.jsx)(t.p,{children:"Node Replacement allow you to replace all instances of a given node in your editor with instances of a subclass."}),"\n",(0,a.jsx)(t.h2,{id:"use-case",children:"Use Case"}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:'In earlier versions of this documentation, "Node Replacement" was called "Node Overrides".\nWe\'ve changed the name to match the terms used in the implementation.'})}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["If your use case only requires adding ad-hoc data to existing nodes, you may be able to use the ",(0,a.jsx)(t.a,{href:"/docs/concepts/node-state",children:"NodeState"})," API instead of subclassing and node replacement."]})}),"\n",(0,a.jsxs)(t.p,{children:["Some of the most commonly used Lexical Nodes are owned and maintained by the core library. For example, ParagraphNode, HeadingNode, QuoteNode, List(Item)Node etc - these are all provided by Lexical packages, which provides an easier out-of-the-box experience for some editor features, but makes it difficult to override their behavior. For instance, if you wanted to change the behavior of ListNode, you would typically extend the class and override the methods. However, how would you tell Lexical to use ",(0,a.jsx)(t.em,{children:"your"})," ListNode subclass in the ListPlugin instead of using the core ListNode? That's where Node Replacement can help."]}),"\n",(0,a.jsx)(t.p,{children:"Node Replacement allow you to replace all instances of a given node in your editor with instances of a different node class. This can be done through the nodes array in the Editor config:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const editorConfig = {\n    ...\n    nodes=[\n        // Don't forget to register your custom node separately!\n        CustomParagraphNode,\n        {\n            replace: ParagraphNode,\n            with: (node: ParagraphNode) => {\n                return $createCustomParagraphNode();\n            },\n            withKlass: CustomParagraphNode,\n        }\n    ]\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"In the snippet above,"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"replace"}),": Specifies the core node type to be replaced."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"with"}),": Defines a transformation function to replace instances of the original node to the custom node."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"withKlass"}),": This option ensures that behaviors associated with the original node type work seamlessly with the replacement. For instance, node transforms or mutation listeners targeting ParagraphNode will also apply to CustomParagraphNode when withKlass is specified. Without this option, the custom node might not fully integrate with the editor's built-in features, leading to unexpected behavior."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Once this is done, Lexical will replace all ParagraphNode instances with CustomParagraphNode instances. One important use case for this feature is overriding the serialization behavior of core nodes. Check out the full example below."}),"\n",(0,a.jsx)(t.h2,{id:"node-replacement-example",children:"Node Replacement Example"}),"\n",(0,a.jsxs)(t.p,{children:["This example demonstrates using Node Replacement to replace all ",(0,a.jsx)(t.code,{children:"ParagraphNode"})," with a ",(0,a.jsx)(t.code,{children:"CustomParagraphNode"})," that overrides ",(0,a.jsx)(t.code,{children:"createDOM"}),"."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://stackblitz.com/github/facebook/lexical/tree/main/examples/node-replacement?file=src/main.tsx",children:(0,a.jsx)(t.img,{src:"https://developer.stackblitz.com/img/open_in_stackblitz.svg",alt:"Open in StackBlitz"})})}),"\n",(0,a.jsx)("iframe",{width:"100%",height:"600",src:"https://stackblitz.com/github/facebook/lexical/tree/main/examples/node-replacement?embed=1&file=src%2FApp.tsx&terminalHeight=0&ctl=1&showSidebar=0&devtoolsheight=0&view=preview",sandbox:"allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts",title:"Node Replacement Example"})]})}function h(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},22840:function(e,t,n){n.d(t,{Z:()=>r,a:()=>i});var o=n(2784);let a={},s=o.createContext(a);function i(e){let t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);