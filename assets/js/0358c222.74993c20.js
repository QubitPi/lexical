"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["613"],{40938:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>s,default:()=>h,contentTitle:()=>a,assets:()=>d,toc:()=>c,metadata:()=>i});var i=JSON.parse('{"id":"api/interfaces/lexical.StateValueConfig","title":"Interface: StateValueConfig<V>","description":"lexical.StateValueConfig","source":"@site/docs/api/interfaces/lexical.StateValueConfig.md","sourceDirName":"api/interfaces","slug":"/api/interfaces/lexical.StateValueConfig","permalink":"/lexical/docs/api/interfaces/lexical.StateValueConfig","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"id":"lexical.StateValueConfig","title":"Interface: StateValueConfig<V>","custom_edit_url":null},"sidebar":"api","previous":{"title":"SplitAtPointCaretNextOptions","permalink":"/lexical/docs/api/interfaces/lexical.SplitAtPointCaretNextOptions"},"next":{"title":"StaticNodeConfigValue","permalink":"/lexical/docs/api/interfaces/lexical.StaticNodeConfigValue"}}'),l=t(52322),r=t(22840);let s={id:"lexical.StateValueConfig",title:"Interface: StateValueConfig<V>",custom_edit_url:null},a=void 0,d={},c=[{value:"Type parameters",id:"type-parameters",level:2},{value:"Properties",id:"properties",level:2},{value:"isEqual",id:"isequal",level:3},{value:"Type declaration",id:"type-declaration",level:4},{value:"Parameters",id:"parameters",level:5},{value:"Returns",id:"returns",level:5},{value:"Defined in",id:"defined-in",level:4},{value:"parse",id:"parse",level:3},{value:"Type declaration",id:"type-declaration-1",level:4},{value:"Parameters",id:"parameters-1",level:5},{value:"Returns",id:"returns-1",level:5},{value:"Defined in",id:"defined-in-1",level:4},{value:"unparse",id:"unparse",level:3},{value:"Type declaration",id:"type-declaration-2",level:4},{value:"Parameters",id:"parameters-2",level:5},{value:"Returns",id:"returns-2",level:5},{value:"Defined in",id:"defined-in-2",level:4}];function o(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.a,{href:"/lexical/docs/api/modules/lexical",children:"lexical"}),".StateValueConfig"]}),"\n",(0,l.jsx)(n.p,{children:"Configure a value to be used with StateConfig."}),"\n",(0,l.jsx)(n.p,{children:"The value type should be inferred from the definition of parse."}),"\n",(0,l.jsx)(n.p,{children:"If the value type is not JSON serializable, then unparse must also be provided."}),"\n",(0,l.jsx)(n.p,{children:"Values should be treated as immutable, much like React.useState. Mutating\nstored values directly will cause unpredictable behavior, is not supported,\nand may trigger errors in the future."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"Example"})})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"const numberOrNullState = createState('numberOrNull', {parse: (v) => typeof v === 'number' ? v : null});\n//    ^? State<'numberOrNull', StateValueConfig<number | null>>\nconst numberState = createState('number', {parse: (v) => typeof v === 'number' ? v : 0});\n//    ^? State<'number', StateValueConfig<number>>\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Only the parse option is required, it is generally not useful to\noverride ",(0,l.jsx)(n.code,{children:"unparse"})," or ",(0,l.jsx)(n.code,{children:"isEqual"}),". However, if you are using\nnon-primitive types such as Array, Object, Date, or something\nmore exotic then you would want to override this. In these\ncases you might want to reach for third party libraries."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"Example"})})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"const isoDateState = createState('isoDate', {\n  parse: (v): null | Date => {\n    const date = typeof v === 'string' ? new Date(v) : null;\n    return date && !isNaN(date.valueOf()) ? date : null;\n  }\n  isEqual: (a, b) => a === b || (a && b && a.valueOf() === b.valueOf()),\n  unparse: (v) => v && v.toString()\n});\n"})}),"\n",(0,l.jsx)(n.p,{children:"You may find it easier to write a parse function using libraries like\nzod, valibot, ajv, Effect, TypeBox, etc. perhaps with a wrapper function."}),"\n",(0,l.jsx)(n.h2,{id:"type-parameters",children:"Type parameters"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsx)(n.tr,{children:(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Name"})})}),(0,l.jsx)(n.tbody,{children:(0,l.jsx)(n.tr,{children:(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"V"})})})})]}),"\n",(0,l.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,l.jsx)(n.h3,{id:"isequal",children:"isEqual"}),"\n",(0,l.jsxs)(n.p,{children:["\u2022 ",(0,l.jsx)(n.code,{children:"Optional"})," ",(0,l.jsx)(n.strong,{children:"isEqual"}),": (",(0,l.jsx)(n.code,{children:"a"}),": ",(0,l.jsx)(n.code,{children:"V"}),", ",(0,l.jsx)(n.code,{children:"b"}),": ",(0,l.jsx)(n.code,{children:"V"}),") => ",(0,l.jsx)(n.code,{children:"boolean"})]}),"\n",(0,l.jsx)(n.p,{children:"This is optional and for advanced use cases only."}),"\n",(0,l.jsx)(n.p,{children:"Used to define the equality function so you can use an Array or Object\nas V and still omit default values from the exported JSON."}),"\n",(0,l.jsxs)(n.p,{children:["The default is ",(0,l.jsx)(n.code,{children:"Object.is"}),", but something like ",(0,l.jsx)(n.code,{children:"fast-deep-equal"})," might be\nmore appropriate for your use case."]}),"\n",(0,l.jsx)(n.h4,{id:"type-declaration",children:"Type declaration"}),"\n",(0,l.jsxs)(n.p,{children:["\u25B8 (",(0,l.jsx)(n.code,{children:"a"}),", ",(0,l.jsx)(n.code,{children:"b"}),"): ",(0,l.jsx)(n.code,{children:"boolean"})]}),"\n",(0,l.jsx)(n.h5,{id:"parameters",children:"Parameters"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"a"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"V"})})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"b"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"V"})})]})]})]}),"\n",(0,l.jsx)(n.h5,{id:"returns",children:"Returns"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"boolean"})}),"\n",(0,l.jsx)(n.h4,{id:"defined-in",children:"Defined in"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNodeState.ts#L232",children:"packages/lexical/src/LexicalNodeState.ts:232"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"parse",children:"parse"}),"\n",(0,l.jsxs)(n.p,{children:["\u2022 ",(0,l.jsx)(n.strong,{children:"parse"}),": (",(0,l.jsx)(n.code,{children:"jsonValue"}),": ",(0,l.jsx)(n.code,{children:"unknown"}),") => ",(0,l.jsx)(n.code,{children:"V"})]}),"\n",(0,l.jsx)(n.p,{children:"This function must return a default value when called with undefined,\notherwise it should parse the given JSON value to your type V. Note\nthat it is not required to copy or clone the given value, you can\npass it directly through if it matches the expected type."}),"\n",(0,l.jsx)(n.p,{children:"When you encounter an invalid value, it's up to you to decide\nas to whether to ignore it and return the default value,\nreturn some non-default error value, or throw an error."}),"\n",(0,l.jsx)(n.p,{children:"It is possible for V to include undefined, but if it does, then\nit should also be considered the default value since undefined\ncan not be serialized to JSON so it is indistinguishable from the\ndefault."}),"\n",(0,l.jsxs)(n.p,{children:["Similarly, if your V is a function, then usage of ",(0,l.jsx)(n.a,{href:"/lexical/docs/api/modules/lexical#setstate",children:"$setState"}),"\nmust use an updater function because your type will be indistinguishable\nfrom an updater function."]}),"\n",(0,l.jsx)(n.h4,{id:"type-declaration-1",children:"Type declaration"}),"\n",(0,l.jsxs)(n.p,{children:["\u25B8 (",(0,l.jsx)(n.code,{children:"jsonValue"}),"): ",(0,l.jsx)(n.code,{children:"V"})]}),"\n",(0,l.jsx)(n.h5,{id:"parameters-1",children:"Parameters"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"jsonValue"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"unknown"})})]})})]}),"\n",(0,l.jsx)(n.h5,{id:"returns-1",children:"Returns"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"V"})}),"\n",(0,l.jsx)(n.h4,{id:"defined-in-1",children:"Defined in"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNodeState.ts#L215",children:"packages/lexical/src/LexicalNodeState.ts:215"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h3,{id:"unparse",children:"unparse"}),"\n",(0,l.jsxs)(n.p,{children:["\u2022 ",(0,l.jsx)(n.code,{children:"Optional"})," ",(0,l.jsx)(n.strong,{children:"unparse"}),": (",(0,l.jsx)(n.code,{children:"parsed"}),": ",(0,l.jsx)(n.code,{children:"V"}),") => ",(0,l.jsx)(n.code,{children:"unknown"})]}),"\n",(0,l.jsx)(n.p,{children:"This is optional and for advanced use cases only."}),"\n",(0,l.jsx)(n.p,{children:"You may specify a function that converts V back to JSON.\nThis is mandatory when V is not a JSON serializable type."}),"\n",(0,l.jsx)(n.h4,{id:"type-declaration-2",children:"Type declaration"}),"\n",(0,l.jsxs)(n.p,{children:["\u25B8 (",(0,l.jsx)(n.code,{children:"parsed"}),"): ",(0,l.jsx)(n.code,{children:"unknown"})]}),"\n",(0,l.jsx)(n.h5,{id:"parameters-2",children:"Parameters"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(n.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"parsed"})}),(0,l.jsx)(n.td,{style:{textAlign:"left"},children:(0,l.jsx)(n.code,{children:"V"})})]})})]}),"\n",(0,l.jsx)(n.h5,{id:"returns-2",children:"Returns"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"unknown"})}),"\n",(0,l.jsx)(n.h4,{id:"defined-in-2",children:"Defined in"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNodeState.ts#L222",children:"packages/lexical/src/LexicalNodeState.ts:222"})})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},22840:function(e,n,t){t.d(n,{Z:()=>a,a:()=>s});var i=t(2784);let l={},r=i.createContext(l);function s(e){let n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);