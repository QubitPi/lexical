"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["5211"],{56633:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>s,default:()=>h,contentTitle:()=>a,assets:()=>d,toc:()=>l,metadata:()=>r});var r=JSON.parse('{"id":"concepts/listeners","title":"Listeners","description":"Listeners are a mechanism that lets the Editor instance inform the user when a certain operation has occurred. All listeners follow a reactive pattern where you can do an operation upon something happening in the future. All listeners also return a function that easily allows for the","source":"@site/docs/concepts/listeners.md","sourceDirName":"concepts","slug":"/concepts/listeners","permalink":"/lexical/docs/concepts/listeners","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/listeners.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Node Cloning","permalink":"/lexical/docs/concepts/node-cloning"},"next":{"title":"Node Transforms","permalink":"/lexical/docs/concepts/transforms"}}'),i=n(52322),o=n(22840);let s={},a="Listeners",d={},l=[{value:"<code>registerUpdateListener</code>",id:"registerupdatelistener",level:2},{value:"<code>registerTextContentListener</code>",id:"registertextcontentlistener",level:2},{value:"<code>registerMutationListener</code>",id:"registermutationlistener",level:2},{value:"<code>registerEditableListener</code>",id:"registereditablelistener",level:2},{value:"<code>registerDecoratorListener</code>",id:"registerdecoratorlistener",level:2},{value:"<code>registerRootListener</code>",id:"registerrootlistener",level:2}];function c(e){let t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"listeners",children:"Listeners"})}),"\n",(0,i.jsx)(t.p,{children:"Listeners are a mechanism that lets the Editor instance inform the user when a certain operation has occurred. All listeners follow a reactive pattern where you can do an operation upon something happening in the future. All listeners also return a function that easily allows for the\nlistener to be unregistered. Below are the different listeners that Lexical supports today:"}),"\n",(0,i.jsx)(t.h2,{id:"registerupdatelistener",children:(0,i.jsx)(t.code,{children:"registerUpdateListener"})}),"\n",(0,i.jsx)(t.p,{children:"Get notified when Lexical commits an update to the DOM."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const removeUpdateListener = editor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n\n// Do not forget to unregister the listener when no longer needed!\nremoveUpdateListener();\n"})}),"\n",(0,i.jsx)(t.p,{children:"The update listener callbacks receives a single argument containing the follow properties:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"editorState"})," the latest updated Editor State"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"prevEditorState"})," the previous Editor State"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tags"})," a Set of all tags that were passed to the update"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'One thing to be aware of is "waterfall" updates. This is where you might schedule an update inside an update\nlistener, as shown below:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"editor.registerUpdateListener(({editorState}) => {\n  // Read the editorState and maybe get some value.\n  editorState.read(() => {\n    // ...\n  });\n\n  // Then schedule another update.\n  editor.update(() => {\n    // ...\n  });\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The problem with this pattern is that it means we end up doing two DOM updates, when we likely could have\ndone it in a single DOM update. This can have an impact on performance, which is important in a text editor.\nTo avoid this, we recommend looking into ",(0,i.jsx)(t.a,{href:"/lexical/docs/concepts/transforms",children:"Node Transforms"}),", which allow you to listen to node changes and\ntransform them as part of the same given update, meaning no waterfalls!"]}),"\n",(0,i.jsx)(t.h2,{id:"registertextcontentlistener",children:(0,i.jsx)(t.code,{children:"registerTextContentListener"})}),"\n",(0,i.jsx)(t.p,{children:"Get notified when Lexical commits an update to the DOM and the text content of the editor changes from\nthe previous state of the editor. If the text content is the same between updates, no notifications to\nthe listeners will happen."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const removeTextContentListener = editor.registerTextContentListener(\n  (textContent) => {\n    // The latest text content of the editor!\n    console.log(textContent);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveTextContentListener();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"registermutationlistener",children:(0,i.jsx)(t.code,{children:"registerMutationListener"})}),"\n",(0,i.jsx)(t.p,{children:"Get notified when a specific type of Lexical node has been mutated. There are three states of mutation:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"created"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"destroyed"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"updated"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Mutation listeners are great for tracking the lifecycle of specific types of node. They can be used to\nhandle external UI state and UI features relating to specific types of node."}),"\n",(0,i.jsx)(t.p,{children:"If any existing nodes are in the DOM, and skipInitialization is not true, the listener\nwill be called immediately with an updateTag of 'registerMutationListener' where all\nnodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n(whose default was previously true for backwards compatibility with <=0.16.1 but has been changed to false as of 0.21.0)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const removeMutationListener = editor.registerMutationListener(\n  MyCustomNode,\n  (mutatedNodes, { updateTags, dirtyLeaves, prevEditorState }) => {\n    // mutatedNodes is a Map where each key is the NodeKey, and the value is the state of mutation.\n    for (let [nodeKey, mutation] of mutatedNodes) {\n      console.log(nodeKey, mutation)\n    }\n  },\n  {skipInitialization: false}\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveMutationListener();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"registereditablelistener",children:(0,i.jsx)(t.code,{children:"registerEditableListener"})}),"\n",(0,i.jsxs)(t.p,{children:["Get notified when the editor's mode has changed. The editor's mode can be changed\nvia ",(0,i.jsx)(t.code,{children:"editor.setEditable(boolean)"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const removeEditableListener = editor.registerEditableListener(\n  (editable) => {\n    // The editor's mode is passed in!\n    console.log(editable);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveEditableListener();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"registerdecoratorlistener",children:(0,i.jsx)(t.code,{children:"registerDecoratorListener"})}),"\n",(0,i.jsxs)(t.p,{children:["Get notified when the editor's decorator object changes. The decorator object contains\nall ",(0,i.jsx)(t.code,{children:"DecoratorNode"})," keys -> their decorated value. This is primarily used with external\nUI frameworks."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const removeDecoratorListener = editor.registerDecoratorListener(\n  (decorators) => {\n    // The editor's decorators object is passed in!\n    console.log(decorators);\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveDecoratorListener();\n"})}),"\n",(0,i.jsx)(t.h2,{id:"registerrootlistener",children:(0,i.jsx)(t.code,{children:"registerRootListener"})}),"\n",(0,i.jsxs)(t.p,{children:["Get notified when the editor's root DOM element (the content editable Lexical attaches to) changes. This is primarily used to\nattach event listeners to the root element. ",(0,i.jsx)(t.em,{children:"The root listener function is executed directly upon registration and then on any subsequent update."})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const removeRootListener = editor.registerRootListener(\n  (rootElement, prevRootElement) => {\n   //add listeners to the new root element\n   //remove listeners from the old root element\n  },\n);\n\n// Do not forget to unregister the listener when no longer needed!\nremoveRootListener();\n"})})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},22840:function(e,t,n){n.d(t,{Z:()=>a,a:()=>s});var r=n(2784);let i={},o=r.createContext(i);function s(e){let t=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);