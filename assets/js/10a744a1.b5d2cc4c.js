"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["4968"],{79626:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>d,default:()=>p,contentTitle:()=>r,assets:()=>o,toc:()=>c,metadata:()=>s});var s=JSON.parse('{"id":"concepts/updates","title":"Updates","description":"Updates in Lexical are synchronous operations that mutate the editor state (except in nested update scenarios which should be deprecated). The reconciliation process (DOM updates) is batched for performance reasons. This batching of DOM updates means we can avoid unnecessary re-renders and optimize the rendering process.","source":"@site/docs/concepts/updates.md","sourceDirName":"concepts","slug":"/concepts/updates","permalink":"/lexical/docs/concepts/updates","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/updates.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Node Traversals with NodeCaret","permalink":"/lexical/docs/concepts/traversals"},"next":{"title":"lexical (core)","permalink":"/lexical/docs/packages/lexical"}}'),a=n(52322),i=n(22840);let d={},r="Updates",o={},c=[{value:"Update Tags",id:"update-tags",level:2},{value:"Common Update Tags",id:"common-update-tags",level:3},{value:"Tag Validation",id:"tag-validation",level:3},{value:"Custom Tags",id:"custom-tags",level:3}];function l(e){let t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"updates",children:"Updates"})}),"\n",(0,a.jsx)(t.p,{children:"Updates in Lexical are synchronous operations that mutate the editor state (except in nested update scenarios which should be deprecated). The reconciliation process (DOM updates) is batched for performance reasons. This batching of DOM updates means we can avoid unnecessary re-renders and optimize the rendering process."}),"\n",(0,a.jsx)(t.h2,{id:"update-tags",children:"Update Tags"}),"\n",(0,a.jsx)(t.p,{children:"Update tags are string identifiers that can be attached to an update to indicate its type or purpose. They can be used to control how updates are processed, merged, or handled by listeners. Multiple tags can be used in a single update."}),"\n",(0,a.jsx)(t.p,{children:"You can add tags in two ways:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Using the ",(0,a.jsx)(t.code,{children:"tag"})," option in ",(0,a.jsx)(t.code,{children:"editor.update()"}),":"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {HISTORY_PUSH_TAG, PASTE_TAG} from 'lexical';\n\neditor.update(() => {\n  // Your update code\n}, {\n  tag: HISTORY_PUSH_TAG // Single tag\n});\n\neditor.update(() => {\n  // Your update code\n}, {\n  tag: [HISTORY_PUSH_TAG, PASTE_TAG] // Multiple tags\n});\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"2",children:["\n",(0,a.jsxs)(t.li,{children:["Using the ",(0,a.jsx)(t.code,{children:"$addUpdateTag()"})," function within an update:"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {HISTORY_PUSH_TAG} from 'lexical';\n\neditor.update(() => {\n  $addUpdateTag(HISTORY_PUSH_TAG);\n  // Your update code\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You can check if a tag is present using ",(0,a.jsx)(t.code,{children:"$hasUpdateTag()"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {HISTORIC_TAG} from 'lexical';\n\neditor.update(() => {\n  $addUpdateTag(HISTORIC_TAG);\n  console.log($hasUpdateTag(HISTORIC_TAG)); // true\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note: While update tags can be checked within the same update using ",(0,a.jsx)(t.code,{children:"$hasUpdateTag()"}),", they are typically accessed in update and mutation listeners through the ",(0,a.jsx)(t.code,{children:"tags"})," and ",(0,a.jsx)(t.code,{children:"updateTags"})," properties in their respective payloads. Here's the more common usage pattern:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {HISTORIC_TAG} from 'lexical';\n\neditor.registerUpdateListener(({tags}) => {\n  if (tags.has(HISTORIC_TAG)) {\n    // Handle updates with historic tag\n  }\n});\n\neditor.registerMutationListener(MyNode, (mutations) => {\n  // updateTags contains tags from the current update\n  if (mutations.updateTags.has(HISTORIC_TAG)) {\n    // Handle mutations with historic tag\n  }\n});\n"})}),"\n",(0,a.jsx)(t.h3,{id:"common-update-tags",children:"Common Update Tags"}),"\n",(0,a.jsx)(t.p,{children:"Lexical provides several built-in update tags that are exported as constants:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"HISTORIC_TAG"}),": Indicates that the update is related to history operations (undo/redo)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"HISTORY_PUSH_TAG"}),": Forces a new history entry to be created"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"HISTORY_MERGE_TAG"}),": Merges the current update with the previous history entry"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"PASTE_TAG"}),": Indicates that the update is related to a paste operation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"COLLABORATION_TAG"}),": Indicates that the update is related to collaborative editing"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SKIP_COLLAB_TAG"}),": Indicates that the update should skip collaborative sync"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SKIP_SCROLL_INTO_VIEW_TAG"}),": Prevents scrolling the selection into view"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SKIP_DOM_SELECTION_TAG"}),": Prevents updating the DOM selection (useful for updates that shouldn't affect focus)"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"tag-validation",children:"Tag Validation"}),"\n",(0,a.jsx)(t.p,{children:"To prevent typos and ensure type safety when using update tags, Lexical exports constants for all built-in tags. It's recommended to always use these constants instead of string literals:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {\n  HISTORIC_TAG,\n  HISTORY_PUSH_TAG,\n  COLLABORATION_TAG,\n} from 'lexical';\n\neditor.update(() => {\n  // Using constants ensures type safety and prevents typos\n  $addUpdateTag(HISTORIC_TAG);\n  \n  // These constants can be used in update options\n  editor.update(() => {\n    // Your update code\n  }, {\n    tag: HISTORY_PUSH_TAG\n  });\n  \n  // And in listener checks\n  editor.registerUpdateListener(({tags}) => {\n    if (tags.has(COLLABORATION_TAG)) {\n      // Handle collaborative updates\n    }\n  });\n});\n"})}),"\n",(0,a.jsx)(t.h3,{id:"custom-tags",children:"Custom Tags"}),"\n",(0,a.jsx)(t.p,{children:"While Lexical provides common tags as constants, you can also define your own constants for custom tags to maintain consistency and type safety:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// Define your custom tags as constants\nconst MY_FEATURE_TAG = 'my-custom-feature';\nconst MY_UPDATE_TAG = 'my-custom-update';\n\neditor.update(() => {\n  $addUpdateTag(MY_FEATURE_TAG);\n}, {\n  tag: MY_UPDATE_TAG\n});\n\n// Listen for updates with specific tags\neditor.registerUpdateListener(({tags}) => {\n  if (tags.has(MY_FEATURE_TAG)) {\n    // Handle updates from your custom feature\n  }\n});\n"})})]})}function p(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},22840:function(e,t,n){n.d(t,{Z:()=>r,a:()=>d});var s=n(2784);let a={},i=s.createContext(a);function d(e){let t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);