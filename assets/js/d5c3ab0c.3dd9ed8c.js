"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[648],{876:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>h});var a=t(2784);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),p=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},s=function(e){var n=p(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,c=e.parentName,s=r(e,["components","mdxType","originalType","parentName"]),d=p(t),g=i,h=d["".concat(c,".").concat(g)]||d[g]||u[g]||l;return t?a.createElement(h,o(o({ref:n},s),{},{components:t})):a.createElement(h,o({ref:n},s))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=g;var r={};for(var c in n)hasOwnProperty.call(n,c)&&(r[c]=n[c]);r.originalType=e,r[d]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},7667:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var a=t(7896),i=(t(2784),t(876));const l={sidebar_position:1},o="Lexical Plugins",r={unversionedId:"react/plugins",id:"react/plugins",title:"Lexical Plugins",description:"React-based plugins are using Lexical editor instance from `` context:",source:"@site/docs/react/plugins.md",sourceDirName:"react",slug:"/react/plugins",permalink:"/lexical/docs/react/plugins",draft:!1,editUrl:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/react/plugins.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docs",previous:{title:"Introduction",permalink:"/lexical/docs/react/"},next:{title:"Creating a React Plugin",permalink:"/lexical/docs/react/create_plugin"}},c={},p=[{value:"<code>LexicalPlainTextPlugin</code>",id:"lexicalplaintextplugin",level:3},{value:"<code>LexicalRichTextPlugin</code>",id:"lexicalrichtextplugin",level:3},{value:"<code>LexicalOnChangePlugin</code>",id:"lexicalonchangeplugin",level:3},{value:"Running Hooks in <code>LexicalOnChangePlugin</code>",id:"running-hooks-in-lexicalonchangeplugin",level:4},{value:"<code>LexicalHistoryPlugin</code>",id:"lexicalhistoryplugin",level:3},{value:"<code>LexicalLinkPlugin</code>",id:"lexicallinkplugin",level:3},{value:"<code>LexicalListPlugin</code>",id:"lexicallistplugin",level:3},{value:"<code>LexicalCheckListPlugin</code>",id:"lexicalchecklistplugin",level:3},{value:"<code>LexicalTablePlugin</code>",id:"lexicaltableplugin",level:3},{value:"<code>LexicalTabIndentationPlugin</code>",id:"lexicaltabindentationplugin",level:3},{value:"<code>LexicalAutoLinkPlugin</code>",id:"lexicalautolinkplugin",level:3},{value:"<code>LexicalClearEditorPlugin</code>",id:"lexicalcleareditorplugin",level:3},{value:"<code>LexicalMarkdownShortcutPlugin</code>",id:"lexicalmarkdownshortcutplugin",level:3},{value:"<code>TableOfContentsPlugin</code>",id:"tableofcontentsplugin",level:3},{value:"<code>LexicalEditorRefPlugin</code>",id:"lexicaleditorrefplugin",level:3}],s={toc:p},d="wrapper";function u(e){let{components:n,...l}=e;return(0,i.kt)(d,(0,a.Z)({},s,l,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"lexical-plugins"},"Lexical Plugins"),(0,i.kt)("p",null,"React-based plugins are using Lexical editor instance from ",(0,i.kt)("inlineCode",{parentName:"p"},"<LexicalComposer>")," context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from '@lexical/react/LexicalPlainTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\nimport {OnChangePlugin} from '@lexical/react/LexicalOnChangePlugin';\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const initialConfig = {\n  namespace: 'MyEditor',\n  theme,\n  onError,\n};\n\n<LexicalComposer initialConfig={initialConfig}>\n  <PlainTextPlugin\n    contentEditable={<ContentEditable />}\n    placeholder={<div>Enter some text...</div>}\n  />\n  <HistoryPlugin />\n  <OnChangePlugin onChange={onChange} />\n  ...\n</LexicalComposer>\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: Many plugins might require you to register the one or many Lexical nodes in order for the plugin to work. You can do this by passing a reference to the node to the ",(0,i.kt)("inlineCode",{parentName:"p"},"nodes")," array in your initial editor configuration.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const initialConfig = {\n  namespace: 'MyEditor',\n  theme,\n  nodes: [ListNode, ListItemNode], // Pass the references to the nodes here\n  onError,\n};\n")),(0,i.kt)("h3",{id:"lexicalplaintextplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalPlainTextPlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/plain-text")," that adds major features for plain text editing, including typing, deletion and copy/pasting"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<PlainTextPlugin\n  contentEditable={<ContentEditable />}\n  placeholder={<div>Enter some text...</div>}\n  ErrorBoundary={LexicalErrorBoundary}\n/>\n")),(0,i.kt)("h3",{id:"lexicalrichtextplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalRichTextPlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/rich-text")," that adds major features for rich text editing, including typing, deletion, copy/pasting, indent/outdent and bold/italic/underline/strikethrough text formatting"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<RichTextPlugin\n  contentEditable={<ContentEditable />}\n  placeholder={<div>Enter some text...</div>}\n  ErrorBoundary={LexicalErrorBoundary}\n/>\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"LexicalRichTextPlugin"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/lexical/discussions/2649#discussioncomment-3179738"},"does NOT offer the rich text ",(0,i.kt)("em",{parentName:"a"},"toolbar")," menus"),"\nsuch as the one shown below:"),(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("img",{alt:"Error loading toolbar-menu-example.png",src:t(6468).Z,width:"1242",height:"474"})),(0,i.kt)("p",{parentName:"admonition"},"The toolbar plugin, however, can be implemented by ourselves by following\n",(0,i.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/lexical-rich-text-example-57px3t"},"this example"),". In order to get rid of ",(0,i.kt)("strong",{parentName:"p"},"styles.css"),", we\nwill replace it with ",(0,i.kt)("a",{parentName:"p",href:"https://qubitpi.github.io/styled-components-website/"},"styled-component"),". For example, in\n",(0,i.kt)("strong",{parentName:"p"},"style.css")," we define dropdown as"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-css"},".dropdown {\n  z-index: 5;\n  display: block;\n  position: absolute;\n  box-shadow: 0 12px 28px 0 rgba(0, 0, 0, 0.2), 0 2px 4px 0 rgba(0, 0, 0, 0.1),\n    inset 0 0 0 1px rgba(255, 255, 255, 0.5);\n  border-radius: 8px;\n  min-width: 100px;\n  min-height: 40px;\n  background-color: #fff;\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"We will have a ",(0,i.kt)("strong",{parentName:"p"},"styled.ts")," file alongside with ",(0,i.kt)("strong",{parentName:"p"},"ToolbarPlugin.js")," with the contents"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import styled from "styled-components";\n\nexport const Dropdown = styled.div`\n  z-index: 5;\n  display: block;\n  position: absolute;\n  box-shadow: 0 12px 28px 0 rgba(0, 0, 0, 0.2), 0 2px 4px 0 rgba(0, 0, 0, 0.1),\n    inset 0 0 0 1px rgba(255, 255, 255, 0.5);\n  border-radius: 8px;\n  min-width: 100px;\n  min-height: 40px;\n  background-color: #fff;\n`;\n')),(0,i.kt)("p",{parentName:"admonition"},"Then we can replace "),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'    <div className="dropdown" ref={dropDownRef}>\n      ...\n    </div>\n')),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"    <Dropdown\n      ref={dropDownRef}\n    >\n      ...\n    </Dropdown>\n"))),(0,i.kt)("h3",{id:"lexicalonchangeplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalOnChangePlugin")),(0,i.kt)("p",null,"Plugin that calls ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," whenever Lexical state is updated. Using ",(0,i.kt)("inlineCode",{parentName:"p"},"ignoreHistoryMergeTagChange")," (",(0,i.kt)("inlineCode",{parentName:"p"},"true")," by default) and ",(0,i.kt)("inlineCode",{parentName:"p"},"ignoreSelectionChange")," (",(0,i.kt)("inlineCode",{parentName:"p"},"false")," by default) can give more granular control over changes that are causing ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," call"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<OnChangePlugin onChange={onChange} />\n")),(0,i.kt)("p",null,"The TypeScript signature of ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"onChange: (editorState: EditorState, editor: LexicalEditor) => void;\n")),(0,i.kt)("p",null,"We are free to pass any or no argument at all to ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," in TypeScript. For example, the following definition is\nvalid:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"onst onChange = function (editorState: EditorState): void {\n  ...\n}\n")),(0,i.kt)("h4",{id:"running-hooks-in-lexicalonchangeplugin"},"Running Hooks in ",(0,i.kt)("inlineCode",{parentName:"h4"},"LexicalOnChangePlugin")),(0,i.kt)("p",null,"What if our ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," logic depends on things other than ",(0,i.kt)("inlineCode",{parentName:"p"},"editorState")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"editor"),"? For example, we might need to\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/lexical/discussions/3355"},"communicate with an external database")," to log the editor's\nmodified date or have to sync with a Redux store by dispatching something inside ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange"),". Is there a good way to\npass such logic into ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange"),"? Yes."),(0,i.kt)("p",null,"Let's take Redux as an example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export type EditorProps = {\n  updateSomeData: (someData: any) => void\n}\n\nfunction Editor(props: EditorProps): JSX.Element {\n\n  const onChange = function (editorState: EditorState): void {\n    editorState.read(() => {\n      // Read the contents of the EditorState here.\n      ...\n\n      props.updateSomeData(transformEditorStateToSomeData(editorState))\n    })\n  }\n  \n  const editorConfig = { ... };\n\n  return (\n    <LexicalComposer initialConfig={editorConfig}>\n      <div className=\"editor-container\">\n        <div className=\"editor-inner\">\n          <OnChangePlugin onChange={onChange} />\n        </div>\n      </div>\n    </LexicalComposer>\n  );\n}\n\nconst mapDispatchToProps = (dispatch: Dispatch<Action>) => ({\n  updateSomeData: (someData: any) => { dispatch({ type: '...', payload: '...' }) }\n})\n\nexport default withBus(connect(null, mapDispatchToProps)(Editor))\n")),(0,i.kt)("p",null,"The key is to pass custom logic (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"updateSomeData"),") through functional programming without having to modifying\n",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"OnChangePlugin")," signatures."),(0,i.kt)("h3",{id:"lexicalhistoryplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalHistoryPlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/history")," that adds support for history stack management and ",(0,i.kt)("inlineCode",{parentName:"p"},"undo")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"redo")," commands"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<HistoryPlugin />\n")),(0,i.kt)("h3",{id:"lexicallinkplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalLinkPlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/link")," that adds support for links, including ",(0,i.kt)("inlineCode",{parentName:"p"},"toggleLink")," command support that toggles link for selected text"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<LinkPlugin />\n")),(0,i.kt)("h3",{id:"lexicallistplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalListPlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/list")," that adds support for lists (ordered and unordered)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<ListPlugin />\n")),(0,i.kt)("h3",{id:"lexicalchecklistplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalCheckListPlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/list")," that adds support for check lists. Note that it requires some css to render check/uncheck marks. See PlaygroundEditorTheme.css for details."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<CheckListPlugin />\n")),(0,i.kt)("h3",{id:"lexicaltableplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalTablePlugin")),(0,i.kt)("p",null,"React wrapper for ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/table")," that adds support for tables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<TablePlugin />\n")),(0,i.kt)("h3",{id:"lexicaltabindentationplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalTabIndentationPlugin")),(0,i.kt)("p",null,"Plugin that allows tab indentation in combination with ",(0,i.kt)("inlineCode",{parentName:"p"},"@lexical/rich-text"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<TabIndentationPlugin />\n")),(0,i.kt)("h3",{id:"lexicalautolinkplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalAutoLinkPlugin")),(0,i.kt)("p",null,"Plugin will convert text into links based on passed matchers list. In example below whenever user types url-like string it will automaticaly convert it into a link node"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const URL_MATCHER =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/;\n\nconst MATCHERS = [\n  (text) => {\n    const match = URL_MATCHER.exec(text);\n    if (match === null) {\n      return null;\n    }\n    const fullMatch = match[0];\n    return {\n      index: match.index,\n      length: fullMatch.length,\n      text: fullMatch,\n      url: fullMatch.startsWith('http') ? fullMatch : `https://${fullMatch}`,\n      // attributes: { rel: 'noreferrer', target: '_blank' }, // Optional link attributes\n    };\n  },\n];\n\n...\n\n<AutoLinkPlugin matchers={MATCHERS} />\n")),(0,i.kt)("h3",{id:"lexicalcleareditorplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalClearEditorPlugin")),(0,i.kt)("p",null,"Adds ",(0,i.kt)("inlineCode",{parentName:"p"},"clearEditor")," command support to clear editor's content"),(0,i.kt)("h3",{id:"lexicalmarkdownshortcutplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalMarkdownShortcutPlugin")),(0,i.kt)("p",null,"Adds markdown shortcut support: headings, lists, code blocks, quotes, links and inline styles (bold, italic, strikethrough)"),(0,i.kt)("h3",{id:"tableofcontentsplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"TableOfContentsPlugin")),(0,i.kt)("p",null,"This plugin allows you to navigate to certain sections of the page by clicking on headings that exist inside these sections. Once you load the plugin, it automatically collects and injects the headings of the page inside the table of contents, then it listens to any deletions or modifications to those headings and updates the table of contents. Additionally, it's able to track any newly added headings and inserts them in the table of contents once they are created. This plugin also supports lazy loading - so you can defer adding the plugin until when the user needs it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<TableOfContentsPlugin />\n")),(0,i.kt)("p",null,"You can alternatively leverage the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"LexicalTableOfContents")," API, which provides you with all the functioanlity that ",(0,i.kt)("inlineCode",{parentName:"p"},"TableOfContentsPlugin")," provides, but without any styling.\nIn order to use ",(0,i.kt)("inlineCode",{parentName:"p"},"LexicalTableOfContents"),", you need to pass a callback function in its children. This callback function gives you access to the up-to-date data of the table of contents. You can access this data through a single parameter for the callback which comes in the form of an array of arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"[[headingKey, headingTextContent, headingTag], [], [], ...]"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"headingKey"),": Unique key that identifies the heading.",(0,i.kt)("inlineCode",{parentName:"p"},"headingTextContent"),": A string of the exact text of the heading.",(0,i.kt)("inlineCode",{parentName:"p"},"headingTag"),": A string that reads either 'h1', 'h2', or 'h3'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"<LexicalTableOfContents>\n  {(tableOfContentsArray) => {\n    return <MyCustomTableOfContetsPlugin tableOfContents={tableOfContentsArray} />;\n  }}\n</LexicalTableOfContents>\n")),(0,i.kt)("h3",{id:"lexicaleditorrefplugin"},(0,i.kt)("inlineCode",{parentName:"h3"},"LexicalEditorRefPlugin")),(0,i.kt)("p",null,"Allows you to get a ref to the underlying editor instance outside of LexicalComposer, which is convenient when you want to interact with the editor\nfrom a separate part of your application."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"  const editorRef = useRef(null);\n  <LexicalEditorRefPlugin editorRef={ref}>\n")))}u.isMDXComponent=!0},6468:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/toolbar-menu-example-cdc16b66c376c740ae5acc5e0891a1b0.png"}}]);