"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[6915],{876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),d=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(n),u=a,h=m["".concat(s,".").concat(u)]||m[u]||c[u]||i;return n?o.createElement(h,r(r({ref:t},p),{},{components:n})):o.createElement(h,r({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9599:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var o=n(7896),a=(n(2784),n(876));const i={},r="Serialization & Deserialization",l={unversionedId:"concepts/serialization",id:"concepts/serialization",title:"Serialization & Deserialization",description:"Internally, Lexical maintains the state of a given editor in memory, updating it in response to user inputs. Sometimes, it's useful to convert this state into a serialized format in order to transfer it between editors or store it for retrieval at some later time. In order to make this process easier, Lexical provides some APIs that allow Nodes to specify how they should be represented in common serialized formats.",source:"@site/docs/concepts/serialization.md",sourceDirName:"concepts",slug:"/concepts/serialization",permalink:"/lexical/docs/concepts/serialization",draft:!1,editUrl:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/serialization.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Read Mode / Edit Mode",permalink:"/lexical/docs/concepts/read-only"},next:{title:"Working with DOM Events",permalink:"/lexical/docs/concepts/dom-events"}},s={},d=[{value:"HTML",id:"html",level:2},{value:"Lexical -&gt; HTML",id:"lexical---html",level:3},{value:"<code>LexicalNode.exportDOM()</code>",id:"lexicalnodeexportdom",level:4},{value:"HTML -&gt; Lexical",id:"html---lexical",level:3},{value:"<code>LexicalNode.importDOM()</code>",id:"lexicalnodeimportdom",level:4},{value:"JSON",id:"json",level:2},{value:"Lexical -&gt; JSON",id:"lexical---json",level:3},{value:"<code>LexicalNode.exportJSON()</code>",id:"lexicalnodeexportjson",level:4},{value:"<code>LexicalNode.importJSON()</code>",id:"lexicalnodeimportjson",level:4},{value:"Versioning &amp; Breaking Changes",id:"versioning--breaking-changes",level:3}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"serialization--deserialization"},"Serialization & Deserialization"),(0,a.kt)("p",null,"Internally, Lexical maintains the state of a given editor in memory, updating it in response to user inputs. Sometimes, it's useful to convert this state into a serialized format in order to transfer it between editors or store it for retrieval at some later time. In order to make this process easier, Lexical provides some APIs that allow Nodes to specify how they should be represented in common serialized formats."),(0,a.kt)("h2",{id:"html"},"HTML"),(0,a.kt)("p",null,"Currently, HTML serialization is primarily used to transfer data between Lexical and non-Lexical editors (such as Google Docs or Quip) via the copy & paste functionality in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/lexical/blob/main/packages/lexical-clipboard/README.md"},(0,a.kt)("inlineCode",{parentName:"a"},"@lexical/clipboard")),", but we also offer generic utilities for converting ",(0,a.kt)("inlineCode",{parentName:"p"},"Lexical")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"HTML")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"HTML")," -> ",(0,a.kt)("inlineCode",{parentName:"p"},"Lexical")," in our ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md"},(0,a.kt)("inlineCode",{parentName:"a"},"@lexical/html"))," package."),(0,a.kt)("h3",{id:"lexical---html"},"Lexical -> HTML"),(0,a.kt)("p",null,"When generating HTML from an editor you can pass in a selection object to narrow it down to a certain section or pass in null to convert the whole editor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {$generateHtmlFromNodes} from '@lexical/html';\n\nconst htmlString = $generateHtmlFromNodes(editor, selection | null);\n")),(0,a.kt)("h4",{id:"lexicalnodeexportdom"},(0,a.kt)("inlineCode",{parentName:"h4"},"LexicalNode.exportDOM()")),(0,a.kt)("p",null,"You can control how a ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode")," is represented as HTML by adding an ",(0,a.kt)("inlineCode",{parentName:"p"},"exportDOM()")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"exportDOM(editor: LexicalEditor): DOMExportOutput\n")),(0,a.kt)("p",null,"When transforming an editor state into HTML, we simply traverse the current editor state (or the selected subset thereof) and call the ",(0,a.kt)("inlineCode",{parentName:"p"},"exportDOM")," method for each Node in order to convert it to an ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElement"),"."),(0,a.kt)("p",null,'Sometimes, it\'s necessary or useful to do some post-processing after a node has been converted to HTML. For this, we expose the "after" API on ',(0,a.kt)("inlineCode",{parentName:"p"},"DOMExportOutput"),", which allows ",(0,a.kt)("inlineCode",{parentName:"p"},"exportDOM")," to specify a function that should be run after the conversion to an ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElement")," has happened."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type DOMExportOutput = {\n  after?: (generatedElement: ?HTMLElement) => ?HTMLElement,\n  element?: HTMLElement | null,\n};\n")),(0,a.kt)("p",null,"If the element property is null in the return value of exportDOM, that Node will not be represented in the serialized output."),(0,a.kt)("h3",{id:"html---lexical"},"HTML -> Lexical"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {$generateNodesFromDOM} from '@lexical/html';\n\neditor.update(() => {\n  // In the browser you can use the native DOMParser API to parse the HTML string.\n  const parser = new DOMParser();\n  const dom = parser.parseFromString(htmlString, textHtmlMimeType);\n\n  // Once you have the DOM instance it's easy to generate LexicalNodes.\n  const nodes = $generateNodesFromDOM(editor, dom);\n\n  // Select the root\n  $getRoot().select();\n\n  // Insert them at a selection.\n  $insertNodes(nodes);\n});\n")),(0,a.kt)("p",null,"If you are running in headless mode, you can do it this way using JSDOM:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {createHeadlessEditor} from '@lexical/headless';\nimport {$generateNodesFromDOM} from '@lexical/html';\n\n// Once you've generated LexicalNodes from your HTML you can now initialize an editor instance with the parsed nodes.\nconst editorNodes = [] // Any custom nodes you register on the editor\nconst editor = createHeadlessEditor({ ...config, nodes: editorNodes });\n\neditor.update(() => {\n  // In a headless environment you can use a package such as JSDom to parse the HTML string.\n  const dom = new JSDOM(htmlString);\n\n  // Once you have the DOM instance it's easy to generate LexicalNodes.\n  const nodes = $generateNodesFromDOM(editor, dom.window.document);\n\n  // Select the root\n  $getRoot().select();\n\n  // Insert them at a selection.\n  const selection = $getSelection();\n  selection.insertNodes(nodes);\n});\n")),(0,a.kt)("h4",{id:"lexicalnodeimportdom"},(0,a.kt)("inlineCode",{parentName:"h4"},"LexicalNode.importDOM()")),(0,a.kt)("p",null,"You can control how an ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElement")," is represented in ",(0,a.kt)("inlineCode",{parentName:"p"},"Lexical")," by adding an ",(0,a.kt)("inlineCode",{parentName:"p"},"importDOM()")," method to your ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"static importDOM(): DOMConversionMap | null;\n")),(0,a.kt)("p",null,"The return value of ",(0,a.kt)("inlineCode",{parentName:"p"},"importDOM")," is a map of the lower case (DOM) ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName"},"Node.nodeName")," property to an object that specifies a conversion function and a priority for that conversion. This allows ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNodes")," to specify which type of DOM nodes they can convert and what the relative priority of their conversion should be. This is useful in cases where a DOM Node with specific attributes should be interpreted as one type of ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode"),", and otherwise it should be represented as another type of ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type DOMConversionMap = {\n  [NodeName]: <T: HTMLElement>(node: T) => DOMConversion | null,\n};\n\nexport type DOMConversion = {\n  conversion: DOMConversionFn,\n  priority: 0 | 1 | 2 | 3 | 4,\n};\n\nexport type DOMConversionFn = (\n  element: Node,\n  parent?: Node,\n  preformatted?: boolean,\n) => DOMConversionOutput;\n\nexport type DOMConversionOutput = {\n  after?: (childLexicalNodes: Array<LexicalNode>) => Array<LexicalNode>,\n  forChild?: DOMChildConversion,\n  node: LexicalNode | null,\n};\n\nexport type DOMChildConversion = (\n  lexicalNode: LexicalNode,\n) => LexicalNode | null | void;\n")),(0,a.kt)("p",null,"@lexical/code provides a good example of the usefulness of this design. GitHub uses HTML ",(0,a.kt)("inlineCode",{parentName:"p"},"<table>")," elements to represent the structure of copied code in HTML. If we interpreted all HTML ",(0,a.kt)("inlineCode",{parentName:"p"},"<table>")," elements as literal tables, then code pasted from GitHub would appear in Lexical as a Lexical TableNode. Instead, CodeNode specifies that it can handle ",(0,a.kt)("inlineCode",{parentName:"p"},"<table>")," elements too:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class CodeNode extends ElementNode {\n...\nstatic importDOM(): DOMConversionMap | null {\n  return {\n    ...\n    table: (node: Node) => {\n      if (isGitHubCodeTable(node as HTMLTableElement)) {\n        return {\n          conversion: convertTableElement,\n          priority: 3,\n        };\n      }\n      return null;\n    },\n    ...\n  };\n}\n...\n}\n")),(0,a.kt)("p",null,"If the imported ",(0,a.kt)("inlineCode",{parentName:"p"},"<table>")," doesn't align with the expected GitHub code HTML, then we return null and allow the node to be handled by lower priority conversions."),(0,a.kt)("p",null,"Much like ",(0,a.kt)("inlineCode",{parentName:"p"},"exportDOM"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"importDOM")," exposes APIs to allow for post-processing of converted Nodes. The conversion function returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"DOMConversionOutput")," which can specify a function to run for each converted child (forChild) or on all the child nodes after the conversion is complete (after). The key difference here is that ",(0,a.kt)("inlineCode",{parentName:"p"},"forChild")," runs for every deeply nested child node of the current node, whereas ",(0,a.kt)("inlineCode",{parentName:"p"},"after")," will run only once after the transformation of the node and all its children is complete. Finally, ",(0,a.kt)("inlineCode",{parentName:"p"},"preformatted")," flag indicates that nested text content is preformatted (similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"<pre>")," tag) and all newlines and spaces should be preserved as is."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type DOMConversionFn = (\n  element: Node,\n  parent?: Node,\n  preformatted?: boolean,\n) => DOMConversionOutput;\n\nexport type DOMConversionOutput = {\n  after?: (childLexicalNodes: Array<LexicalNode>) => Array<LexicalNode>,\n  forChild?: DOMChildConversion,\n  node: LexicalNode | null,\n};\n\nexport type DOMChildConversion = (\n  lexicalNode: LexicalNode,\n  parentLexicalNode: LexicalNode | null | undefined,\n) => LexicalNode | null;\n")),(0,a.kt)("h2",{id:"json"},"JSON"),(0,a.kt)("h3",{id:"lexical---json"},"Lexical -> JSON"),(0,a.kt)("p",null,"To generate a JSON snapshot from an ",(0,a.kt)("inlineCode",{parentName:"p"},"EditorState"),", you can call the ",(0,a.kt)("inlineCode",{parentName:"p"},"toJSON()")," method on the ",(0,a.kt)("inlineCode",{parentName:"p"},"EditorState")," object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const editorState = editor.getEditorState();\nconst json = editorState.toJSON();\n")),(0,a.kt)("p",null,"Alternatively, if you are trying to generate a stringified version of the ",(0,a.kt)("inlineCode",{parentName:"p"},"EditorState"),", you can simply using ",(0,a.kt)("inlineCode",{parentName:"p"},"JSON.stringify")," directly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const editorState = editor.getEditorState();\nconst jsonString = JSON.stringify(editorState);\n")),(0,a.kt)("h4",{id:"lexicalnodeexportjson"},(0,a.kt)("inlineCode",{parentName:"h4"},"LexicalNode.exportJSON()")),(0,a.kt)("p",null,"You can control how a ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode")," is represented as JSON by adding an ",(0,a.kt)("inlineCode",{parentName:"p"},"exportJSON()")," method. It's important to ensure your serialized JSON node has a ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," field and a ",(0,a.kt)("inlineCode",{parentName:"p"},"children")," field if it's an ",(0,a.kt)("inlineCode",{parentName:"p"},"ElementNode"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type SerializedLexicalNode = {\n  type: string;\n  version: number;\n};\n\nexportJSON(): SerializedLexicalNode\n")),(0,a.kt)("p",null,"When transforming an editor state into JSON, we simply traverse the current editor state and call the ",(0,a.kt)("inlineCode",{parentName:"p"},"exportJSON")," method for each Node in order to convert it to a ",(0,a.kt)("inlineCode",{parentName:"p"},"SerializedLexicalNode")," object that represents the JSON object for the given node. The built-in nodes from Lexical already have a JSON representation defined, but you'll need to define ones for your own custom nodes."),(0,a.kt)("p",null,"Here's an example of ",(0,a.kt)("inlineCode",{parentName:"p"},"exportJSON")," for the ",(0,a.kt)("inlineCode",{parentName:"p"},"HeadingNode"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type SerializedHeadingNode = Spread<\n  {\n    tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  },\n  SerializedElementNode\n>;\n\nexportJSON(): SerializedHeadingNode {\n  return {\n    ...super.exportJSON(),\n    tag: this.getTag(),\n    type: 'heading',\n    version: 1,\n  };\n}\n")),(0,a.kt)("h4",{id:"lexicalnodeimportjson"},(0,a.kt)("inlineCode",{parentName:"h4"},"LexicalNode.importJSON()")),(0,a.kt)("p",null,"You can control how a ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode")," is serialized back into a node from JSON by adding an ",(0,a.kt)("inlineCode",{parentName:"p"},"importJSON()")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type SerializedLexicalNode = {\n  type: string;\n  version: number;\n};\n\nimportJSON(jsonNode: SerializedLexicalNode): LexicalNode\n")),(0,a.kt)("p",null,"This method works in the opposite way to how ",(0,a.kt)("inlineCode",{parentName:"p"},"exportJSON")," works. Lexical uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," field on the JSON object to determine what Lexical node class it needs to map to, so keeping the ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," field consistent with the ",(0,a.kt)("inlineCode",{parentName:"p"},"getType()")," of the LexicalNode is essential."),(0,a.kt)("p",null,"Here's an example of ",(0,a.kt)("inlineCode",{parentName:"p"},"importJSON")," for the ",(0,a.kt)("inlineCode",{parentName:"p"},"HeadingNode"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"static importJSON(serializedNode: SerializedHeadingNode): HeadingNode {\n  const node = $createHeadingNode(serializedNode.tag);\n  node.setFormat(serializedNode.format);\n  node.setIndent(serializedNode.indent);\n  node.setDirection(serializedNode.direction);\n  return node;\n}\n")),(0,a.kt)("h3",{id:"versioning--breaking-changes"},"Versioning & Breaking Changes"),(0,a.kt)("p",null,"It's important to note that you should avoid making breaking changes to existing fields in your JSON object, especially if backwards compatibility is an important part of your editor. That's why we recommend using a version field to separate the different changes in your node as you add or change functionality of custom nodes. Here's the serialized type definition for Lexical's base ",(0,a.kt)("inlineCode",{parentName:"p"},"TextNode")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import type {Spread} from 'lexical';\n\n// Spread is a Typescript utility that allows us to spread the properties\n// over the base SerializedLexicalNode type.\nexport type SerializedTextNode = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n  },\n  SerializedLexicalNode\n>;\n")),(0,a.kt)("p",null,"If we wanted to make changes to the above ",(0,a.kt)("inlineCode",{parentName:"p"},"TextNode"),", we should be sure to not remove or change an existing property, as this can cause data corruption. Instead, opt to add the functionality as a new property field instead, and use the version to determine how to handle the differences in your node."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export type SerializedTextNodeV1 = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n  },\n  SerializedLexicalNode\n>;\n\nexport type SerializedTextNodeV2 = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n    // Our new field we've added\n    newField: string,\n    // Notice the version is now 2\n    version: 2,\n  },\n  SerializedLexicalNode\n>;\n\nexport type SerializedTextNode = SerializedTextNodeV1 | SerializedTextNodeV2;\n")))}c.isMDXComponent=!0}}]);