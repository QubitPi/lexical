"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["3617"],{72601:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>s,default:()=>h,contentTitle:()=>o,assets:()=>d,toc:()=>c,metadata:()=>i});var i=JSON.parse('{"id":"concepts/traversals","title":"Node Traversals with NodeCaret","description":"NodeCaret offers a unified and efficient way for traversing the document","source":"@site/docs/concepts/traversals.md","sourceDirName":"concepts","slug":"/concepts/traversals","permalink":"/docs/concepts/traversals","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/traversals.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Working with DOM Events","permalink":"/docs/concepts/dom-events"},"next":{"title":"Updates","permalink":"/docs/concepts/updates"}}'),r=n(52322),a=n(22840);let s={},o="Node Traversals with NodeCaret",d={},c=[{value:"Concepts",id:"concepts",level:2},{value:"NodeCaret",id:"nodecaret",level:3},{value:"SiblingCaret",id:"siblingcaret",level:3},{value:"ChildCaret",id:"childcaret",level:3},{value:"PointCaret",id:"pointcaret",level:3},{value:"TextPointCaret",id:"textpointcaret",level:3},{value:"TextPointCaretSlice",id:"textpointcaretslice",level:3},{value:"CaretRange",id:"caretrange",level:3},{value:"Traversal Strategies",id:"traversal-strategies",level:2},{value:"Adjacent Caret Traversals",id:"adjacent-caret-traversals",level:3},{value:"Examples",id:"examples",level:3},{value:"Depth First Caret Traversals",id:"depth-first-caret-traversals",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Future Direction",id:"future-direction",level:2},{value:"History",id:"history",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Caret",id:"caret",level:3},{value:"Origin",id:"origin",level:3},{value:"ChildCaret / SiblingCaret",id:"childcaret--siblingcaret",level:3},{value:"Direction",id:"direction",level:3},{value:"Distance",id:"distance",level:3}];function l(e){let t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"node-traversals-with-nodecaret",children:"Node Traversals with NodeCaret"})}),"\n",(0,r.jsx)(t.p,{children:"NodeCaret offers a unified and efficient way for traversing the document\ntree, making it much easier to correctly implement traversals and avoid\nedge cases around empty nodes and collapsed selections."}),"\n",(0,r.jsx)(t.p,{children:"These new low-level functions were all designed to work together as a\nfully featured relatively lightweight API to use in the core to\nallow us to gradually address some edge cases and then simplify and shrink\nthe code. We expect higher-level utilities to be developed and shipped\nin @lexical/utils or another module at a later date. The current overhead\nshould be less than 3kB in a production environment."}),"\n",(0,r.jsx)(t.p,{children:"The NodeCaret API was introduced in lexical v0.25.0."}),"\n",(0,r.jsx)(t.h2,{id:"concepts",children:"Concepts"}),"\n",(0,r.jsxs)(t.p,{children:["The core concept with ",(0,r.jsx)(t.code,{children:"NodeCaret"})," is that you can represent any specific\npoint in the document by using an ",(0,r.jsx)(t.code,{children:"origin"})," node, a ",(0,r.jsx)(t.code,{children:"direction"})," that\npoints towards an adjacent node (",(0,r.jsx)(t.code,{children:"next"})," or ",(0,r.jsx)(t.code,{children:"previous"}),"), and a ",(0,r.jsx)(t.code,{children:"type"}),"\nto specify whether the arrow points towards a sibling (",(0,r.jsx)(t.code,{children:"sibling"}),") or\ntowards a child (",(0,r.jsx)(t.code,{children:"child"}),")."]}),"\n",(0,r.jsxs)(t.p,{children:["All of these types have a ",(0,r.jsx)(t.code,{children:"D"})," type parameter that must be a ",(0,r.jsx)(t.code,{children:"CaretDirection"}),", so you\ncan not accidentally mix up ",(0,r.jsx)(t.code,{children:"next"})," and ",(0,r.jsx)(t.code,{children:"previous"})," carets. Many of them\nalso have a ",(0,r.jsx)(t.code,{children:"T"})," type parameter that encodes the type of the ",(0,r.jsx)(t.code,{children:"origin"})," node."]}),"\n",(0,r.jsxs)(t.admonition,{type:"tip",children:[(0,r.jsxs)(t.p,{children:["The methods of a caret are designed to operate on nodes attached to the ",(0,r.jsx)(t.code,{children:"origin"}),"\nin the designated direction, not the ",(0,r.jsx)(t.code,{children:"origin"})," itself. For example, this code is\na no-op because it will attach a node to the ",(0,r.jsx)(t.code,{children:"origin"}),", and then remove the node\nthat was just attached."]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// The origin is unaffected (other than being marked dirty)\ncaret.insert($createTextNode('no-op')).remove();\n"})})]}),"\n",(0,r.jsxs)(t.admonition,{type:"warning",children:[(0,r.jsxs)(t.p,{children:["Carets are immutable, and designed for low-level usage. There is no attempt\nfor carets to automatically update based on changes to the document\n(this is a common source of bugs when working with ",(0,r.jsx)(t.code,{children:"RangeSelection"}),").\nFunctions and methods that work with carets and are expected to change the\nstructure of the document will always return a possibly new caret."]}),(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"origin"})," of a caret is the exact version of the object that it was\nconstructed with, all accessor methods on that origin will generally call\n",(0,r.jsx)(t.code,{children:"origin.getLatest()"})," so the operations will see the latest version."]})]}),"\n",(0,r.jsx)(t.h3,{id:"nodecaret",children:"NodeCaret"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"NodeCaret"})," is any ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," or any ",(0,r.jsx)(t.code,{children:"ChildCaret"})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Typically constructed with ",(0,r.jsx)(t.code,{children:"$getChildCaretOrSelf($getSiblingCaret(origin, direction))"}),"\nwhich returns a ",(0,r.jsx)(t.code,{children:"ChildCaret"})," when the origin is an ",(0,r.jsx)(t.code,{children:"ElementNode"})]}),"\n"]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["This type does not include ",(0,r.jsx)(t.code,{children:"TextPointCaret"})," or ",(0,r.jsx)(t.code,{children:"TextPointCaretSlice"}),",\nso you will not have to consider those edge cases when you see this\nmore specific type."]})}),"\n",(0,r.jsx)(t.h3,{id:"siblingcaret",children:"SiblingCaret"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"SiblingCaret"})," is a caret that points towards a sibling of the origin"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Constructed with ",(0,r.jsx)(t.code,{children:"$getSiblingCaret(origin: LexicalNode, direction: CaretDirection)"})]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"next"})," direction points towards the right"]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"previous"})," direction points towards the left"]}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{}),(0,r.jsxs)(t.th,{children:["\u2192 direction: ",(0,r.jsx)(t.code,{children:"'next'"})]}),(0,r.jsxs)(t.th,{children:["\u2190 direction: ",(0,r.jsx)(t.code,{children:"'previous'"})]})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"getParentAtCaret()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.getParent()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.getParent()"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"getNodeAtCaret()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.getNextSibling()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.getPreviousSibling()"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"insert(node)"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.insertAfter(node)"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.insertBefore(node)"})})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"childcaret",children:"ChildCaret"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"ChildCaret"})," is a caret that points towards the first or last child of the origin"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Constructed with ",(0,r.jsx)(t.code,{children:"$getChildCaret(origin: ElementNode, direction: CaretDirection)"})]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"next"})," direction points towards the first child"]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"previous"})," direction points towards the last child"]}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{}),(0,r.jsxs)(t.th,{children:["\u2198 direction: ",(0,r.jsx)(t.code,{children:"'next'"})]}),(0,r.jsxs)(t.th,{children:["\u2199 direction: ",(0,r.jsx)(t.code,{children:"'previous'"})]})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"getParentAtCaret()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"getNodeAtCaret()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.getFirstChild()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.getLastChild()"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"insert(node)"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.splice(0, 0, node)"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"origin.append(node)"})})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"pointcaret",children:"PointCaret"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"PointCaret"})," is any ",(0,r.jsx)(t.code,{children:"TextPointCaret"}),", ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," or ",(0,r.jsx)(t.code,{children:"ChildCaret"}),". This\ntype can be used to represent any point in the document that ",(0,r.jsx)(t.code,{children:"PointType"})," can represent."]}),"\n",(0,r.jsx)(t.h3,{id:"textpointcaret",children:"TextPointCaret"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"TextPointCaret"})," is basically a ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," with a ",(0,r.jsx)(t.code,{children:"TextNode"})," origin and an ",(0,r.jsx)(t.code,{children:"offset"})," property"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Constructed with ",(0,r.jsx)(t.code,{children:"$getTextPointCaret(origin, direction, offset)"})]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"offset"})," property is an absolute index into the string"]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"next"})," direction implies all text content after ",(0,r.jsx)(t.code,{children:"offset"})]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"previous"})," direction implies all text content before ",(0,r.jsx)(t.code,{children:"offset"})]}),"\n",(0,r.jsxs)(t.li,{children:["All methods that are also present on ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," behave in the same way"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"textpointcaretslice",children:"TextPointCaretSlice"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"TextPointCaretSlice"})," is a wrapper for ",(0,r.jsx)(t.code,{children:"TextPointCaret"})," that provides a signed ",(0,r.jsx)(t.code,{children:"distance"}),"."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Constructed with ",(0,r.jsx)(t.code,{children:"$getTextPointCaretSlice(caret, distance)"})]}),"\n",(0,r.jsxs)(t.li,{children:["There are convenience methods like ",(0,r.jsx)(t.code,{children:"removeTextSlice()"})," and ",(0,r.jsx)(t.code,{children:"getTextContent()"}),",\nso it's not generally necessary to know the implementation details here"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Math.min(caret.offset, caret.offset + distance)"})," refers to the start offset of the slice"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Math.max(caret.offset, caret.offset + distance)"})," refers to the end offset of the slice"]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"direction"})," of the caret is generally ignored when working with a\n",(0,r.jsx)(t.code,{children:"TextPointCaretSlice"}),", the slice is in absolute string coordinates"]}),"\n"]}),"\n",(0,r.jsxs)(t.admonition,{type:"info",children:[(0,r.jsxs)(t.p,{children:["The property name ",(0,r.jsx)(t.code,{children:"distance"})," was chosen because ",(0,r.jsx)(t.code,{children:"length"})," and ",(0,r.jsx)(t.code,{children:"size"})," are\ncommonly used on other data structures in JavaScript and Lexical, and they\nare overwhelmingly non-negative. While most uses of ",(0,r.jsx)(t.code,{children:"distance"})," are also\nnon-negative, in some contexts such as computer graphics it is not uncommon\nto use\n",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Signed_distance_function",children:"Signed distance functions"}),"\nwhere the distance metric is signed."]}),(0,r.jsxs)(t.p,{children:["In SDF terms, the subset of the space is ",(0,r.jsx)(t.code,{children:"[offset, \u221E)"}),". Any coordinate less\nthan the ",(0,r.jsx)(t.code,{children:"offset"})," boundary is a negative distance; otherwise the distance is\nnon-negative."]})]}),"\n",(0,r.jsx)(t.h3,{id:"caretrange",children:"CaretRange"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"CaretRange"})," contains a pair of ",(0,r.jsx)(t.code,{children:"PointCaret"})," that are in the same direction. It\nis equivalent in purpose to a ",(0,r.jsx)(t.code,{children:"RangeSelection"}),", and is what you would generally\nuse for depth first traversals."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Constructed with ",(0,r.jsx)(t.code,{children:"$getCaretRange(anchor, focus)"}),", ",(0,r.jsx)(t.code,{children:"$caretRangeFromSelection(selection)"}),",\nor ",(0,r.jsx)(t.code,{children:"$extendCaretToRange(anchor)"})]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"anchor"}),' is the start of the range, generally where the selection originated,\nand it is "anchored" in place because when a selection grows or shrinks only the\n',(0,r.jsx)(t.code,{children:"focus"})," will be moved"]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"focus"})," is the end of the range, where the blinking cursor is, it's the current\nfocus of the user"]}),"\n",(0,r.jsxs)(t.li,{children:["Anchor and focus must point in the same direction. The ",(0,r.jsx)(t.code,{children:"anchor"})," points towards the first\nnode ",(0,r.jsx)(t.em,{children:"in the range"})," and the focus points towards the first node ",(0,r.jsx)(t.em,{children:"not in the range"})]}),"\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:"getTextSlices()"})," method is essential to handle the literal edge cases where\nthe anchor and/or focus are a ",(0,r.jsx)(t.code,{children:"TextPointCaret"}),". These edges are ",(0,r.jsx)(t.em,{children:"not"})," included\nin the default caret iteration of the ",(0,r.jsx)(t.code,{children:"CaretRange"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["If you are iterating a ",(0,r.jsx)(t.code,{children:"CaretRange"})," you must consider the ",(0,r.jsx)(t.code,{children:"getTextSlices()"}),"\nseparately, they are not included in the iteration. This is so you don't have\nto consider ",(0,r.jsx)(t.code,{children:"TextPointCaretSlice"})," at every step. They are literal edge cases\nthat can only be at the start and/or end and typically have special\ntreatment (splitting instead of removing, for example)."]})}),"\n",(0,r.jsx)(t.h2,{id:"traversal-strategies",children:"Traversal Strategies"}),"\n",(0,r.jsx)(t.h3,{id:"adjacent-caret-traversals",children:"Adjacent Caret Traversals"}),"\n",(0,r.jsx)(t.p,{children:"The lowest level building block for traversals with NodeCaret is the adjacent caret\ntraversal, which is supported directly by methods of NodeCaret."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"getAdjacentCaret()"})," - Gets a ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," for the node attached to\n",(0,r.jsx)(t.code,{children:"origin"})," in direction. If there is no attached node, it will return ",(0,r.jsx)(t.code,{children:"null"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"getParentCaret(rootMode)"})," - Gets a ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," for the parent node\nof ",(0,r.jsx)(t.code,{children:"origin"})," in the same direction. If there is no parent node, or the parent\nis a root according to ",(0,r.jsx)(t.code,{children:"rootMode"}),", then it will return ",(0,r.jsx)(t.code,{children:"null"}),". ",(0,r.jsx)(t.code,{children:"rootMode"}),"\nmay be ",(0,r.jsx)(t.code,{children:"'root'"})," to only return ",(0,r.jsx)(t.code,{children:"null"})," for ",(0,r.jsx)(t.code,{children:"RootNode"})," or ",(0,r.jsx)(t.code,{children:"'shadowRoot'"})," to\nreturn ",(0,r.jsx)(t.code,{children:"null"})," for ",(0,r.jsx)(t.code,{children:"RootNode"})," or any ",(0,r.jsx)(t.code,{children:"ElementNode"})," parent where\n",(0,r.jsx)(t.code,{children:"isShadowRoot()"})," returns true"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"getChildCaret()"})," - Gets a ",(0,r.jsx)(t.code,{children:"ChildCaret"})," for this origin, or ",(0,r.jsx)(t.code,{children:"null"})," if the\norigin is not an ",(0,r.jsx)(t.code,{children:"ElementNode"}),". Will return ",(0,r.jsx)(t.code,{children:"this"})," if the caret is already\na ",(0,r.jsx)(t.code,{children:"ChildCaret"})]}),"\n",(0,r.jsx)(t.p,{children:"For example, iterating all siblings:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// Note that NodeCaret<D> already implements Iterable<NodeCaret<D>> in this\n// way, so this function is not very useful. You can just use startCaret as\n// the iterable.\nfunction *$iterSiblings<D extends CaretDirection>(\n  startCaret: NodeCaret<D>\n): Iterable<SiblingCaret<LexicalNode, D>> {\n  // Note that we start at the adjacent caret. The start caret\n  // points away from the origin node, so we do not want to\n  // trick ourselves into thinking that that origin is included.\n  for (\n    let caret = startCaret.getAdjacentCaret();\n    caret !== null;\n    caret = caret.getAdjacentCaret()\n  ) {\n    yield caret;\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(t.p,{children:"Given the following document tree, here are some examples of using the\nadjacent node traversal:"}),"\n",(0,r.jsx)(t.p,{children:"Root"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Paragraph A","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Text A1"}),"\n",(0,r.jsxs)(t.li,{children:["Link A2","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Text A3"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Text A4"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Paragraph B","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Text B1"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Paragraph C"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// The root does not have sibling nodes\nconst carets = [...$getSiblingCaret($getRoot(), 'next')];\nexpect(carets).toEqual([]);\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// The adjacent node to a ChildNode is its first or last child\n// and is always a SiblingNode. It does not traverse deeper.\nconst carets = [...$getChildCaret($getRoot(), 'next')];\n\n// next starts at the first child\nexpect(carets).toEqual([\n  $getSiblingCaret(paragraphA, 'next'),\n  $getSiblingCaret(paragraphB, 'next'),\n  $getSiblingCaret(paragraphC, 'next'),\n]);\n\n// previous starts at the last child\nconst prevCarets = [...$getChildCaret($getRoot(), 'previous')];\nexpect(prevCarets).toEqual([\n  $getSiblingCaret(paragraphC, 'previous'),\n  $getSiblingCaret(paragraphB, 'previous'),\n  $getSiblingCaret(paragraphA, 'previous'),\n]);\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// The iteration starts at the node where the head of the \"arrow\"\n// is pointing, which is away from the origin (the tail of the \"arrow\").\nconst carets = [...$getSiblingCaret(paragraphB, 'next')];\nexpect(carets).toEqual([\n  $getSiblingCaret(paragraphC, 'next'),\n]);\n\nconst prevCarets = [...$getSiblingCaret(paragraphB, 'previous')];\nexpect(prevCarets).toEqual([\n  $getSiblingCaret(paragraphA, 'previous'),\n]);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"depth-first-caret-traversals",children:"Depth First Caret Traversals"}),"\n",(0,r.jsxs)(t.p,{children:["The strategy to do a depth-first caret traversal is to use an adjacent caret\ntraversal and immediately use a ",(0,r.jsx)(t.code,{children:"ChildCaret"})," any time that an ",(0,r.jsx)(t.code,{children:"ElementNode"}),"\norigin is encountered. This strategy yields all possible carets, but each\nElementNode in the traversal may be yielded once or twice (a ",(0,r.jsx)(t.code,{children:"ChildCaret"})," on\nenter, and a ",(0,r.jsx)(t.code,{children:"SiblingCaret"})," on leave). Allowing you to see whether an\n",(0,r.jsx)(t.code,{children:"ElementNode"})," is partially included in the range or not is one of the\nreasons that this abstraction exists."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"function *$iterCaretsDepthFirst<D extends CaretDirection>(\n  startCaret: NodeCaret<D>\n): Iterable<NodeCaret<D>> {\n  function step(prevCaret: NodeCaret<D>): null | NodeCaret<D> {\n    // Get the adjacent SiblingCaret\n    const nextCaret = prevCaret.getAdjacentCaret();\n    return (\n      // If there is a sibling, try and get a ChildCaret from it\n      (nextCaret && nextCaret.getChildCaret()) ||\n      // Return the sibling if there is one\n      nextCaret ||\n      // Return a SiblingCaret of the parent, if there is one\n      prevCaret.getParentCaret('root')\n    );\n  }\n  // You may add an additional check here, usually some specific\n  // caret to terminate the iteration with (such as the parent caret\n  // of startCaret):\n  //\n  //  `caret !== null || caret.is(endCaret)`\n  //\n  for (\n    let caret = step(startCaret);\n    caret !== null;\n    caret = step(caret)\n  ) {\n    yield caret;\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Normally this type of iteration would be done from a ",(0,r.jsx)(t.code,{children:"CaretRange"}),", where you\nwould specify a precise end caret (focus)."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"function $iterCaretsDepthFirst<D extends CaretDirection>(\n  startCaret: NodeCaret<D>,\n  endCaret?: NodeCaret<D>,\n): Iterable<NodeCaret<D>> {\n  return $getCaretRange(\n    startCaret,\n    // Use the root as the default end caret, but you might choose\n    // to use startCaret.getParentCaret('root') for example\n    endCaret || $getSiblingCaret($getRoot(), startCaret.direction)\n  );\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"To get all nodes that are entirely selected between two carets:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"function *$iterNodesDepthFirst<D extends CaretDirection>(\n  startCaret: NodeCaret<D>,\n  endCaret: NodeCaret<D> = $getChildCaret($getRoot(), startCaret.direction),\n): Iterable<LexicalNode> {\n  const seen = new Set<NodeKey>();\n  for (const caret of $getCaretRange(startCaret, endCaret)) {\n    const {origin} = caret;\n    if ($isChildCaret(caret)) {\n      seen.add(origin.getKey());\n    } else if (!$isElementNode(origin) || seen.has(origin.getKey())) {\n      // If the origin is an element and we have not seen it as a ChildCaret\n      // then it was not entirely in the CaretRange\n      yield origin;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"examples-1",children:"Examples"}),"\n",(0,r.jsxs)(t.p,{children:["Given the following document tree, here are some examples of using the\ndepth-first node traversal (with a ",(0,r.jsx)(t.code,{children:"CaretRange"}),"):"]}),"\n",(0,r.jsx)(t.p,{children:"Root"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Paragraph A","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Text A1"}),"\n",(0,r.jsxs)(t.li,{children:["Link A2","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Text A3"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Text A4"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Paragraph B","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Text B1"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Paragraph C"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// A full traversal of the document from root\nconst carets = [...$getCaretRange(\n  // Start with the arrow pointing towards the first child of root\n  $getChildCaret($getRoot(), 'next'),\n  // End when the arrow points away from root\n  $getSiblingCaret($getRoot(), 'next'),\n)];\nexpect(carets).toEqual([\n  $getChildCaret(paragraphA, 'next'),   // enter Paragraph A\n  $getSiblingCaret(textA1, 'next'),\n  $getChildCaret(linkA2, 'next'),       // enter Link A2\n  $getSiblingCaret(textA3, 'next'),\n  $getSiblingCaret(linkA2, 'next'),     // leave Link A2\n  $getSiblingCaret(textA4, 'next'),\n  $getSiblingCaret(paragraphA, 'next'), // leave Paragraph A\n  $getChildCaret(paragraphB, 'next'),   // enter Paragraph B\n  $getSiblingCaret(textB1, 'next'),\n  $getSiblingCaret(paragraphB, 'next'), // leave Paragraph B\n  $getChildCaret(paragraphC, 'next'),   // enter Paragraph C\n  $getSiblingCaret(paragraphC, 'next'), // leave Paragraph C\n]);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"future-direction",children:"Future Direction"}),"\n",(0,r.jsx)(t.p,{children:"It's expected that higher-level abstractions will be built on top of this\noutside of the core, either in @lexical/utils or a separate companion package.\nThis is just designed to be the lowest-level layer with a consistent and\ntype-safe interface. That sort of abstraction will probably look a little bit\nlike cheerio or jQuery, but for working with Lexical documents. It is not\nexpected that more abstractions will be added to the core."}),"\n",(0,r.jsx)(t.p,{children:"In order to reduce code size and eliminate bugs, more of the core will be\nrefactored to use NodeCaret internally."}),"\n",(0,r.jsx)(t.p,{children:'Once this happens, it\'s possible that the internal structure of PointType\nand/or RangeSelection may change to accommodate NodeCaret, as it is more\nresilient to document changes (only changes that directly affect the\norigin node will "break" the point). A simple version of this would be to\ncreate a caret any time that the point changes, and use that caret\nas a fallback if the selection would otherwise be lost.'}),"\n",(0,r.jsx)(t.p,{children:"It may be the case that NodeCaret will become the lowest level API, working\ndirectly with private LexicalNode/ElementNode internals. When/if that happens,\nthe methods on LexicalNode will remain for backwards compatibility,\nbut overriding them will not be supported. It isn't particularly safe to\noverride them as-is anyway, and these overrides are frequently the\nroot cause of bugs (e.g. parents that remove themselves after an operation\non a child, causing the point to be lost unless the caller was sophisticated\nenough to store the array of parents)."}),"\n",(0,r.jsx)(t.h2,{id:"history",children:"History"}),"\n",(0,r.jsx)(t.p,{children:"Before NodeCaret, Lexical's core API offered a relatively low-level DOM-like\ninterface for working with nodes and traversing them. It has accumulated\nmany functions over time for performing various kinds of traversals around\nthe tree (finding ancestors, children, depth, siblings, etc.), but most of\nthem are not implemented in a way that makes them easy to combine\nefficiently, and many of them have edge cases that are difficult to avoid\nand can't really be addressed without breaking compatibility."}),"\n",(0,r.jsx)(t.p,{children:"Many of these functions also have a lot of edge cases, particularly around\nassuming the reference nodes are inclusive. Many are also left-to-right\nbiased, don't offer an iterative version that can be aborted early or\nconsumed on the fly, etc."}),"\n",(0,r.jsxs)(t.p,{children:["Refactoring many of these to use something like ",(0,r.jsx)(t.code,{children:"PointType"})," would almost\nbe sufficient for many of these use cases, but the representation of\nthat type is inefficient and error-prone as any mutation to the tree\nrequires that each point be manually recomputed. ",(0,r.jsx)(t.code,{children:"PointType"})," is also\ndirectionless, forcing a specific left-to-right bias into most APIs.\n",(0,r.jsx)(t.code,{children:"RangeSelection"})," can be used in many cases because a direction can\nbe inferred from any two different points, but that collapses with\na single point. It's also impractical to use ",(0,r.jsx)(t.code,{children:"RangeSelection"}),"\nconcurrently with mutations due to the problems with ",(0,r.jsx)(t.code,{children:"PointType"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"NodeCaret was born out of frustration with these APIs and a desire\nto unify it all in a coherent way to simplify and reduce errors in\nthe core."}),"\n",(0,r.jsx)(t.h2,{id:"terminology",children:"Terminology"}),"\n",(0,r.jsx)(t.h3,{id:"caret",children:"Caret"}),"\n",(0,r.jsx)(t.p,{children:'The term Caret was chosen because it is concise and specific term\nspecific to a point in a text document. Lexical is "an extensible text editor\nframework" so it makes sense that navigation in the document would use\nterms relevant to text. Most other terms such as Cursor or Point\nalready have meanings in Lexical and/or are less specific.'}),"\n",(0,r.jsx)(t.p,{children:"See also:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Caret",children:"Caret"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Caret_navigation",children:"Caret navigation"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"origin",children:"Origin"}),"\n",(0,r.jsxs)(t.p,{children:['The origin is the reference node for a NodeCaret. Absolute coordinates\nare determined by combining this origin node and an "arrow" that points\ntowards to where the adjacent node is (or could be). The "arrow" is\ndetermined by the ',(0,r.jsx)(t.code,{children:"direction"})," and ",(0,r.jsx)(t.code,{children:"type"})," of the caret."]}),"\n",(0,r.jsx)(t.p,{children:'In a way this "arrow" is considered to be something like a unit vector\nto indicate the direction, and adding it to an origin allows you to specify\nan absolute location relative to that origin. Unlike the other coordinate\nsystems available in Lexical, it does not need recomputing whenever\nsiblings or a parent changes, so long as the origin node is still attached.'}),"\n",(0,r.jsx)(t.p,{children:"See also:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Origin_(mathematics)",children:"Origin"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Unit_vector",children:"Unit Vector"})}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"childcaret--siblingcaret",children:"ChildCaret / SiblingCaret"}),"\n",(0,r.jsxs)(t.p,{children:["These were chosen because they match the existing methods on ",(0,r.jsx)(t.code,{children:"ElementNode"}),"\nand ",(0,r.jsx)(t.code,{children:"LexicalNode"})," (",(0,r.jsx)(t.code,{children:"getFirstChild"}),", ",(0,r.jsx)(t.code,{children:"getNextSibling"}),", etc.)"]}),"\n",(0,r.jsx)(t.h3,{id:"direction",children:"Direction"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"'next'"})," and ",(0,r.jsx)(t.code,{children:"'previous'"})," were chosen for direction mostly to match the\nexisting methods such as ",(0,r.jsx)(t.code,{children:"getNextSibling()"})," that exist in DOM and in Lexical.\nUsing other words such as ",(0,r.jsx)(t.code,{children:"'left'"})," and ",(0,r.jsx)(t.code,{children:"'right'"})," would be ambiguous since\ntext direction can be bidirectional and already uses\xa0the terms left-to-right\nand right-to-left."]}),"\n",(0,r.jsx)(t.h3,{id:"distance",children:"Distance"}),"\n",(0,r.jsxs)(t.p,{children:["The property name ",(0,r.jsx)(t.code,{children:"distance"})," was chosen for ",(0,r.jsx)(t.code,{children:"TextPointCaretSlice"})," because\n",(0,r.jsx)(t.code,{children:"length"})," and ",(0,r.jsx)(t.code,{children:"size"})," are commonly used on other data structures in JavaScript\nand Lexical, and they are overwhelmingly non-negative. While most uses of\n",(0,r.jsx)(t.code,{children:"distance"})," are also non-negative, in some contexts such as computer graphics\nit is not uncommon to use\n",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Signed_distance_function",children:"Signed distance functions"}),"\nwhere the distance metric is signed."]}),"\n",(0,r.jsxs)(t.p,{children:["In SDF terms, the subset of the space is ",(0,r.jsx)(t.code,{children:"[offset, \u221E)"}),". Any coordinate less\nthan the ",(0,r.jsx)(t.code,{children:"offset"})," boundary is a negative distance; otherwise the distance is\nnon-negative."]})]})}function h(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},22840:function(e,t,n){n.d(t,{Z:()=>o,a:()=>s});var i=n(2784);let r={},a=i.createContext(r);function s(e){let t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);