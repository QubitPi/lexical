"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["5822"],{58592:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>s,default:()=>h,contentTitle:()=>o,assets:()=>d,toc:()=>l,metadata:()=>i});var i=JSON.parse('{"id":"concepts/editor-state","title":"Editor State","description":"Why is it necessary?","source":"@site/docs/concepts/editor-state.md","sourceDirName":"concepts","slug":"/concepts/editor-state","permalink":"/docs/concepts/editor-state","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/editor-state.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Developer Tools","permalink":"/docs/getting-started/devtools"},"next":{"title":"Nodes","permalink":"/docs/concepts/nodes"}}'),a=n(52322),r=n(22840);let s={},o="Editor State",d={},l=[{value:"Why is it necessary?",id:"why-is-it-necessary",level:2},{value:"Understanding the Editor State",id:"understanding-the-editor-state",level:2},{value:"Updating state",id:"updating-state",level:2},{value:"State update listener",id:"state-update-listener",level:2},{value:"When are Listeners, Transforms, and Commands called?",id:"when-are-listeners-transforms-and-commands-called",level:2},{value:"Synchronous reconciliation with discrete updates",id:"synchronous-reconciliation-with-discrete-updates",level:2},{value:"Cloning state",id:"cloning-state",level:3}];function c(e){let t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"editor-state",children:"Editor State"})}),"\n",(0,a.jsx)(t.h2,{id:"why-is-it-necessary",children:"Why is it necessary?"}),"\n",(0,a.jsx)(t.p,{children:"With Lexical, the source of truth is not the DOM, but rather an underlying state model\nthat Lexical maintains and associates with an editor instance."}),"\n",(0,a.jsx)(t.p,{children:'While HTML is great for storing rich text content it\'s often "way too flexible" when it comes to text editing.\nFor example the following lines of content will produce equal outcome:'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-html",children:"<i><b>Lexical</b></i>\n<i><b>Lex<b><b>ical</b></i>\n<b><i>Lexical</i></b>\n"})}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"See rendered version!"}),(0,a.jsxs)("div",{children:[(0,a.jsx)("i",{children:(0,a.jsx)("b",{children:"Lexical"})}),(0,a.jsxs)("i",{children:[(0,a.jsx)("b",{children:"Lex"}),(0,a.jsx)("b",{children:"ical"})]}),(0,a.jsx)("b",{children:(0,a.jsx)("i",{children:"Lexical"})})]})]}),"\n",(0,a.jsx)(t.p,{children:"Of course, there are ways to normalize all these variants to a single canonical form, however this would require DOM manipulation and so re-rendering of the content. And to overcome this we can use Virtual DOM, or State."}),"\n",(0,a.jsx)(t.p,{children:"On top of that it allows to decouple content structure from content formatting. Let's look at this example stored in HTML:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-html",children:"<p>Why did the JavaScript developer go to the bar? <b>Because he couldn't handle his <i>Promise</i>s</b></p>\n"})}),"\n",(0,a.jsxs)("figure",{class:"text--center",children:[(0,a.jsx)("img",{src:"/img/docs/state-formatting-html.drawio.svg",alt:"Nested structure of the HTML state"}),(0,a.jsx)("figcaption",{children:"Nested structure of the HTML state because of the formatting"})]}),"\n",(0,a.jsx)(t.p,{children:"In contrast, Lexical decouples structure from formatting by offsetting this information to attributes. This allows us to have canonical document structure regardless of the order in which different styles were applied."}),"\n",(0,a.jsxs)("figure",{class:"text--center",children:[(0,a.jsx)("img",{src:"/img/docs/state-formatting-lexical.png",alt:"Flat Lexical state"}),(0,a.jsx)("figcaption",{children:"Flat Lexical state structure"})]}),"\n",(0,a.jsx)(t.h2,{id:"understanding-the-editor-state",children:"Understanding the Editor State"}),"\n",(0,a.jsxs)(t.p,{children:["You can get the latest editor state from an editor by calling ",(0,a.jsx)(t.code,{children:"editor.getEditorState()"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Editor states have two phases:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'During an update they can be thought of as "mutable". See "Updating state" below to\nmutate an editor state.'}),"\n",(0,a.jsx)(t.li,{children:'After an update, the editor state is then locked and deemed immutable from there on. This\neditor state can therefore be thought of as a "snapshot".'}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Editor states contain two core things:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The editor node tree (starting from the root node)."}),"\n",(0,a.jsx)(t.li,{children:"The editor selection (which can be null)."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Editor states are serializable to JSON, and the editor instance provides a useful method\nto deserialize stringified editor states."}),"\n",(0,a.jsx)(t.p,{children:"Here's an example of how you can initialize editor with some state and then persist it:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Get editor initial state (e.g. loaded from backend)\nconst loadContent = async () => {\n  // \'empty\' editor\n  const value = \'{"root":{"children":[{"children":[],"direction":null,"format":"","indent":0,"type":"paragraph","version":1}],"direction":null,"format":"","indent":0,"type":"root","version":1}}\';\n\n  return value;\n}\n\nconst initialEditorState = await loadContent();\nconst editor = createEditor(...);\nregisterRichText(editor, initialEditorState);\n\n...\n\n// Handler to store content (e.g. when user submits a form)\nconst onSubmit = () => {\n  await saveContent(JSON.stringify(editor.getEditorState()));\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"For React it could be something like the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'const initialEditorState = await loadContent();\nconst editorStateRef = useRef(undefined);\n\n<LexicalComposer initialConfig={{\n  editorState: initialEditorState\n}}>\n  <LexicalRichTextPlugin />\n  <LexicalOnChangePlugin onChange={(editorState) => {\n    editorStateRef.current = editorState;\n  }} />\n  <Button label="Save" onPress={() => {\n    if (editorStateRef.current) {\n      saveContent(JSON.stringify(editorStateRef.current))\n    }\n  }} />\n</LexicalComposer>\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Note that Lexical uses ",(0,a.jsx)(t.code,{children:"initialConfig.editorState"})," only once (when it's being initialized) and passing different value later\nwon't be reflected in editor. See \"Update state\" below for proper ways of updating editor state."]}),"\n",(0,a.jsx)(t.h2,{id:"updating-state",children:"Updating state"}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["For a deep dive into how state updates work, check out ",(0,a.jsx)(t.a,{href:"https://dio.la/article/lexical-state-updates",children:"this blog post"})," by Lexical contributor ",(0,a.jsx)(t.a,{href:"https://twitter.com/daniguardio_la",children:"@DaniGuardiola"}),"."]})}),"\n",(0,a.jsxs)(t.p,{children:["The most common way to update the editor is to use ",(0,a.jsx)(t.code,{children:"editor.update()"}),'. Calling this function\nrequires a function to be passed in that will provide access to mutate the underlying\neditor state. When starting a fresh update, the current editor state is cloned and\nused as the starting point. From a technical perspective, this means that Lexical leverages a technique\ncalled double-buffering during updates. There\'s the "current" frozen editor state to represent what was\nmost recently reconciled to the DOM, and another work-in-progress "pending" editor state that represents\nfuture changes for the next reconciliation.']}),"\n",(0,a.jsxs)(t.p,{children:["Reconciling an update is typically an async process that allows Lexical to batch multiple synchronous\nupdates of the editor state together in a single update to the DOM \u2013 improving performance. When\nLexical is ready to commit the update to the DOM, the underlying mutations and changes in the update\nbatch will form a new immutable editor state. Calling ",(0,a.jsx)(t.code,{children:"editor.getEditorState()"})," will then return the\nlatest editor state based on the changes from the update."]}),"\n",(0,a.jsx)(t.p,{children:"Here's an example of how you can update an editor instance:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import {$getRoot, $getSelection} from 'lexical';\nimport {$createParagraphNode} from 'lexical';\n\n// Inside the `editor.update` you can use special $ prefixed helper functions.\n// These functions cannot be used outside the closure, and will error if you try.\n// (If you're familiar with React, you can imagine these to be a bit like using a hook\n// outside of a React function component).\neditor.update(() => {\n  // Get the RootNode from the EditorState\n  const root = $getRoot();\n\n  // Get the selection from the EditorState\n  const selection = $getSelection();\n\n  // Create a new ParagraphNode\n  const paragraphNode = $createParagraphNode();\n\n  // Create a new TextNode\n  const textNode = $createTextNode('Hello world');\n\n  // Append the text node to the paragraph\n  paragraphNode.append(textNode);\n\n  // Finally, append the paragraph to the root\n  root.append(paragraphNode);\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Another way to set state is ",(0,a.jsx)(t.code,{children:"setEditorState"})," method, which replaces current state with the one passed as an argument."]}),"\n",(0,a.jsx)(t.p,{children:"Here's an example of how you can set editor state from a stringified JSON:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const editorState = editor.parseEditorState(editorStateJSONString);\neditor.setEditorState(editorState);\n"})}),"\n",(0,a.jsx)(t.h2,{id:"state-update-listener",children:"State update listener"}),"\n",(0,a.jsx)(t.p,{children:"If you want to know when the editor updates so you can react to the changes, you can add an update\nlistener to the editor, as shown below:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"editor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n"})}),"\n",(0,a.jsx)(t.h2,{id:"when-are-listeners-transforms-and-commands-called",children:"When are Listeners, Transforms, and Commands called?"}),"\n",(0,a.jsx)(t.p,{children:"There are several types of callbacks that can be registered with the editor that are related to\nupdates of the Editor State."}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Callback Type"}),(0,a.jsx)(t.th,{children:"When It's Called"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Update Listener"}),(0,a.jsx)(t.td,{children:"After reconciliation"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Mutation Listener"}),(0,a.jsx)(t.td,{children:"After reconciliation"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Node Transform"}),(0,a.jsxs)(t.td,{children:["During ",(0,a.jsx)(t.code,{children:"editor.update()"}),", after the callback finishes, if any instances of the node type they are registered for were updated"]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Command"}),(0,a.jsxs)(t.td,{children:["As soon as the command is dispatched to the editor (called from an implicit ",(0,a.jsx)(t.code,{children:"editor.update()"}),")"]})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"synchronous-reconciliation-with-discrete-updates",children:"Synchronous reconciliation with discrete updates"}),"\n",(0,a.jsx)(t.p,{children:"While commit scheduling and batching are normally what we want, they can sometimes get in the way."}),"\n",(0,a.jsx)(t.p,{children:"Consider this example: you're trying to manipulate an editor state in a server context and then persist it in a database."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"editor.update(() => {\n  // manipulate the state...\n});\n\nsaveToDatabase(editor.getEditorState().toJSON());\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This code will not work as expected, because the ",(0,a.jsx)(t.code,{children:"saveToDatabase"})," call will happen before the state has been committed.\nThe state that will be saved will be the same one that existed before the update."]}),"\n",(0,a.jsxs)(t.p,{children:["Fortunately, the ",(0,a.jsx)(t.code,{children:"discrete"})," option for ",(0,a.jsx)(t.code,{children:"LexicalEditor.update"})," forces an update to be immediately committed."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"editor.update(() => {\n  // manipulate the state...\n}, {discrete: true});\n\nsaveToDatabase(editor.getEditorState().toJSON());\n"})}),"\n",(0,a.jsx)(t.h3,{id:"cloning-state",children:"Cloning state"}),"\n",(0,a.jsx)(t.p,{children:"Lexical state can be cloned, optionally with custom selection. One of the scenarios where you'd want to do it\nis setting editor's state but not forcing any selection:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// Passing `null` as a selection value to prevent focusing the editor\neditor.setEditorState(editorState.clone(null));\n"})})]})}function h(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},22840:function(e,t,n){n.d(t,{Z:()=>o,a:()=>s});var i=n(2784);let a={},r=i.createContext(a);function s(e){let t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);