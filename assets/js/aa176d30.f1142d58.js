"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["2533"],{72729:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>a,default:()=>x,contentTitle:()=>l,assets:()=>c,toc:()=>h,metadata:()=>o});var o=JSON.parse('{"id":"concepts/nodes","title":"Nodes","description":"Base Nodes","source":"@site/docs/concepts/nodes.mdx","sourceDirName":"concepts","slug":"/concepts/nodes","permalink":"/lexical/docs/concepts/nodes","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/nodes.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Editor State","permalink":"/lexical/docs/concepts/editor-state"},"next":{"title":"Node Replacement","permalink":"/lexical/docs/concepts/node-replacement"}}'),r=t(52322),i=t(22840),d=t(83929),s=t(84828);let a={},l="Nodes",c={},h=[{value:"Base Nodes",id:"base-nodes",level:2},{value:"<code>RootNode</code>",id:"rootnode",level:3},{value:"Semantics and Use Cases",id:"semantics-and-use-cases",level:4},{value:"<code>LineBreakNode</code>",id:"linebreaknode",level:3},{value:"<code>ElementNode</code>",id:"elementnode",level:3},{value:"<code>TextNode</code>",id:"textnode",level:3},{value:"<code>DecoratorNode</code>",id:"decoratornode",level:3},{value:"Node Properties",id:"node-properties",level:2},{value:"Creating custom nodes",id:"creating-custom-nodes",level:2},{value:"Extending <code>ElementNode</code>",id:"extending-elementnode",level:3},{value:"Extending <code>TextNode</code>",id:"extending-textnode",level:3},{value:"Extending <code>DecoratorNode</code>",id:"extending-decoratornode",level:3},{value:"The rest of the boilerplate",id:"the-rest-of-the-boilerplate",level:3},{value:"Creating custom nodes with $config and NodeState",id:"creating-custom-nodes-with-config-and-nodestate",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Extending <code>ElementNode</code> with $config",id:"extending-elementnode-with-config",level:3},{value:"Extending <code>TextNode</code> with $config",id:"extending-textnode-with-config",level:3},{value:"Extending <code>DecoratorNode</code> using $config",id:"extending-decoratornode-using-config",level:3}];function u(e){let n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"nodes",children:"Nodes"})}),"\n",(0,r.jsx)(n.h2,{id:"base-nodes",children:"Base Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["Nodes are a core concept in Lexical. Not only do they form the visual editor view, as part of the ",(0,r.jsx)(n.code,{children:"EditorState"}),", but they also represent the\nunderlying data model for what is stored in the editor at any given time. Lexical has a single core based node, called ",(0,r.jsx)(n.code,{children:"LexicalNode"})," that\nis extended internally to create Lexical's five base nodes:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"RootNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"LineBreakNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ElementNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"TextNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"DecoratorNode"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Of these base nodes, three of them can be extended to create new types of nodes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ElementNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"TextNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"DecoratorNode"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rootnode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalRootNode.ts",children:(0,r.jsx)(n.code,{children:"RootNode"})})}),"\n",(0,r.jsxs)(n.p,{children:["There is only ever a single ",(0,r.jsx)(n.code,{children:"RootNode"})," in an ",(0,r.jsx)(n.code,{children:"EditorState"})," and it is always at the top and it represents the\n",(0,r.jsx)(n.code,{children:"contenteditable"})," itself. This means that the ",(0,r.jsx)(n.code,{children:"RootNode"})," does not have a parent or siblings. It can not be\nsubclassed or replaced."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["To get the text content of the entire editor, you should use ",(0,r.jsx)(n.code,{children:"rootNode.getTextContent()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["To avoid selection issues, Lexical forbids insertion of text nodes directly into a ",(0,r.jsx)(n.code,{children:"RootNode"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"semantics-and-use-cases",children:"Semantics and Use Cases"}),"\n",(0,r.jsxs)(n.p,{children:["Unlike other ",(0,r.jsx)(n.code,{children:"ElementNode"})," subclasses, the ",(0,r.jsx)(n.code,{children:"RootNode"})," has specific characteristics and restrictions to maintain editor integrity:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Non-extensibility"}),(0,r.jsx)(n.br,{}),"\n","The ",(0,r.jsx)(n.code,{children:"RootNode"})," cannot be subclassed or replaced with a custom implementation. It is designed as a fixed part of the editor architecture."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exclusion from Mutation Listeners"}),(0,r.jsx)(n.br,{}),"\n","The ",(0,r.jsx)(n.code,{children:"RootNode"})," does not participate in mutation listeners. Instead, use a root-level or update listener to observe changes at the document level."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compatibility with Node Transforms"}),(0,r.jsx)(n.br,{}),"\n","While the ",(0,r.jsx)(n.code,{children:"RootNode"}),' is not "part of the document" in the traditional sense, it can still appear to be in some cases, such as during serialization or when applying node transforms. A node transform on the ',(0,r.jsx)(n.code,{children:"RootNode"})," will be called at the end of ",(0,r.jsx)(n.em,{children:"every"})," node transform cycle. This is useful in cases where you need something like an update listener that occurs before the editor state is reconciled."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Document-Level Metadata"}),(0,r.jsx)(n.br,{}),"\n","If you are attempting to use the ",(0,r.jsx)(n.code,{children:"RootNode"})," for document-level metadata (e.g., undo/redo support), use the ",(0,r.jsx)(n.a,{href:"/docs/concepts/node-state",children:"NodeState"})," API."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["By design, the ",(0,r.jsx)(n.code,{children:"RootNode"})," serves as a container for the editor's content rather than an active part of the document's logical structure. This approach simplifies operations like serialization and keeps the focus on content nodes."]}),"\n",(0,r.jsx)(n.h3,{id:"linebreaknode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalLineBreakNode.ts",children:(0,r.jsx)(n.code,{children:"LineBreakNode"})})}),"\n",(0,r.jsxs)(n.p,{children:["You should never have ",(0,r.jsx)(n.code,{children:"'\\n'"})," in your text nodes, instead you should use the ",(0,r.jsx)(n.code,{children:"LineBreakNode"})," which represents\n",(0,r.jsx)(n.code,{children:"'\\n'"}),", and more importantly, can work consistently between browsers and operating systems."]}),"\n",(0,r.jsx)(n.h3,{id:"elementnode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalElementNode.ts",children:(0,r.jsx)(n.code,{children:"ElementNode"})})}),"\n",(0,r.jsxs)(n.p,{children:["Used as parent for other nodes, can be block level (",(0,r.jsx)(n.code,{children:"ParagraphNode"}),", ",(0,r.jsx)(n.code,{children:"HeadingNode"}),") or inline (",(0,r.jsx)(n.code,{children:"LinkNode"}),").\nHas various methods which define its behaviour that can be overridden during extension (",(0,r.jsx)(n.code,{children:"isInline"}),", ",(0,r.jsx)(n.code,{children:"canBeEmpty"}),", ",(0,r.jsx)(n.code,{children:"canInsertTextBefore"})," and more)"]}),"\n",(0,r.jsx)(n.h3,{id:"textnode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalTextNode.ts",children:(0,r.jsx)(n.code,{children:"TextNode"})})}),"\n",(0,r.jsx)(n.p,{children:"Leaf type of node that contains text. It also includes few text-specific properties:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"format"})," any combination of ",(0,r.jsx)(n.code,{children:"bold"}),", ",(0,r.jsx)(n.code,{children:"italic"}),", ",(0,r.jsx)(n.code,{children:"underline"}),", ",(0,r.jsx)(n.code,{children:"strikethrough"}),", ",(0,r.jsx)(n.code,{children:"code"}),", ",(0,r.jsx)(n.code,{children:"highlight"}),", ",(0,r.jsx)(n.code,{children:"subscript"})," and ",(0,r.jsx)(n.code,{children:"superscript"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"mode"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"token"})," - acts as immutable node, can't change its content and is deleted all at once"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"segmented"})," - its content deleted by segments (one word at a time), it is editable although node becomes non-segmented once its content is updated"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"style"})," can be used to apply inline css styles to text"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"decoratornode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalDecoratorNode.ts",children:(0,r.jsx)(n.code,{children:"DecoratorNode"})})}),"\n",(0,r.jsx)(n.p,{children:"Wrapper node to insert arbitrary view (component) inside the editor. Decorator node rendering is framework-agnostic and\ncan output components from React, vanilla js or other frameworks."}),"\n",(0,r.jsx)(n.h2,{id:"node-properties",children:"Node Properties"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["If you're using Lexical v0.26.0 or later, you should consider using the ",(0,r.jsx)(n.a,{href:"/docs/concepts/node-state",children:"NodeState"})," API instead of defining properties directly on your subclasses. NodeState features automatic support for ",(0,r.jsx)(n.code,{children:"afterCloneFrom"}),", ",(0,r.jsx)(n.code,{children:"exportJSON"}),", and ",(0,r.jsx)(n.code,{children:"updateFromJSON"})," requiring much less boilerplate and some additional benefits. You may find that you do not need a subclass at all in some situations, since your NodeState can be applied ad-hoc to any node."]})}),"\n",(0,r.jsxs)(n.p,{children:["Lexical nodes can have properties. It's important that these properties are JSON serializable too, so you should never\nbe assigning a property to a node that is a function, Symbol, Map, Set, or any other object that has a different prototype\nthan the built-ins. ",(0,r.jsx)(n.code,{children:"null"}),", ",(0,r.jsx)(n.code,{children:"undefined"}),", ",(0,r.jsx)(n.code,{children:"number"}),", ",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"boolean"}),", ",(0,r.jsx)(n.code,{children:"{}"})," and ",(0,r.jsx)(n.code,{children:"[]"})," are all types of property that can be\nassigned to node."]}),"\n",(0,r.jsxs)(n.p,{children:["By convention, we prefix properties with ",(0,r.jsx)(n.code,{children:"__"})," (double underscore) so that it makes it clear that these properties are private\nand their access should be avoided directly. We opted for ",(0,r.jsx)(n.code,{children:"__"})," instead of ",(0,r.jsx)(n.code,{children:"_"})," because of the fact that some build tooling\nmangles and minifies single ",(0,r.jsx)(n.code,{children:"_"})," prefixed properties to improve code size. However, this breaks down if you're exposing a node\nto be extended outside of your build."]}),"\n",(0,r.jsxs)(n.p,{children:["If you are adding a property that you expect to be modifiable or accessible, then you should always create a set of ",(0,r.jsx)(n.code,{children:"get*()"}),"\nand ",(0,r.jsx)(n.code,{children:"set*()"})," methods on your node for this property. Inside these methods, you'll need to invoke some very important methods\nthat ensure consistency with Lexical's internal immutable system. These methods are ",(0,r.jsx)(n.code,{children:"getWritable()"})," and ",(0,r.jsx)(n.code,{children:"getLatest()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["We recommend that your constructor should always support a zero-argument instantiation in order to better support collab and\nto reduce the amount of boilerplate required. You can always define your ",(0,r.jsx)(n.code,{children:"$create*"})," functions with required arguments."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import type {NodeKey} from 'lexical';\n\nclass MyCustomNode extends SomeOtherNode {\n  __foo: string;\n\n  constructor(foo: string = '', key?: NodeKey) {\n    super(key);\n    this.__foo = foo;\n  }\n\n  setFoo(foo: string): this {\n    // getWritable() creates a clone of the node\n    // if needed, to ensure we don't try and mutate\n    // a stale version of this node.\n    const self = this.getWritable();\n    self.__foo = foo;\n    return self;\n  }\n\n  getFoo(): string {\n    // getLatest() ensures we are getting the most\n    // up-to-date value from the EditorState.\n    const self = this.getLatest();\n    return self.__foo;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Lastly, all nodes should have ",(0,r.jsx)(n.code,{children:"static getType()"}),", ",(0,r.jsx)(n.code,{children:"static clone()"}),", and ",(0,r.jsx)(n.code,{children:"static importJSON()"})," methods.\nLexical uses the type to be able to reconstruct a node back with its associated class prototype\nduring deserialization (important for copy + paste!). Lexical uses cloning to ensure consistency\nbetween creation of new ",(0,r.jsx)(n.code,{children:"EditorState"})," snapshots."]}),"\n",(0,r.jsx)(n.p,{children:"Expanding on the example above with these methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface SerializedCustomNode extends SerializedLexicalNode {\n  foo?: string;\n}\n\nclass MyCustomNode extends SomeOtherNode {\n  __foo: string;\n\n  static getType(): string {\n    return 'custom-node';\n  }\n\n  static clone(node: MyCustomNode): MyCustomNode {\n    // If any state needs to be set after construction, it should be\n    // done by overriding the `afterCloneFrom` instance method.\n    return new MyCustomNode(node.__foo, node.__key);\n  }\n\n  static importJSON(\n    serializedNode: LexicalUpdateJSON<SerializedMyCustomNode>,\n  ): MyCustomNode {\n    return new MyCustomNode().updateFromJSON(serializedNode);\n  }\n\n  constructor(foo: string = '', key?: NodeKey) {\n    super(key);\n    this.__foo = foo;\n  }\n\n  updateFromJSON(\n    serializedNode: LexicalUpdateJSON<SerializedMyCustomNode>,\n  ): this {\n    const self = super.updateFromJSON(serializedNode);\n    return typeof serializedNode.foo === 'string'\n      ? self.setFoo(serializedNode.foo)\n      : self;\n  }\n\n  exportJSON(): SerializedMyCustomNode {\n    const serializedNode: SerializedMyCustomNode = super.exportJSON();\n    const foo = this.getFoo();\n    if (foo !== '') {\n      serializedNode.foo = foo;\n    }\n    return serializedNode;\n  }\n\n  setFoo(foo: string): this {\n    // getWritable() creates a clone of the node\n    // if needed, to ensure we don't try and mutate\n    // a stale version of this node.\n    const self = this.getWritable();\n    self.__foo = foo;\n    return self;\n  }\n\n  getFoo(): string {\n    // getLatest() ensures we are getting the most\n    // up-to-date value from the EditorState.\n    const self = this.getLatest();\n    return self.__foo;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"creating-custom-nodes",children:"Creating custom nodes"}),"\n",(0,r.jsx)(n.p,{children:"As mentioned above, Lexical exposes three base nodes that can be extended."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Did you know? Nodes such as ",(0,r.jsx)(n.code,{children:"ElementNode"})," are already extended in the core by Lexical, such as ",(0,r.jsx)(n.code,{children:"ParagraphNode"})," and ",(0,r.jsx)(n.code,{children:"RootNode"}),"!"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"extending-elementnode",children:["Extending ",(0,r.jsx)(n.code,{children:"ElementNode"})]}),"\n",(0,r.jsxs)(n.p,{children:["Below is an example of how you might extend ",(0,r.jsx)(n.code,{children:"ElementNode"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {ElementNode, LexicalNode} from 'lexical';\n\nexport class CustomParagraph extends ElementNode {\n  static getType(): string {\n    return 'custom-paragraph';\n  }\n\n  static clone(node: CustomParagraph): CustomParagraph {\n    return new CustomParagraph(node.__key);\n  }\n\n  createDOM(): HTMLElement {\n    // Define the DOM element here\n    const dom = document.createElement('p');\n    return dom;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    // Returning false tells Lexical that this node does not need its\n    // DOM element replacing with a new copy from createDOM.\n    return false;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It's also good etiquette to provide some ",(0,r.jsx)(n.code,{children:"$"})," prefixed utility functions for\nyour custom ",(0,r.jsx)(n.code,{children:"ElementNode"})," so that others can easily consume and validate nodes\nare that of your custom node. Here's how you might do this for the above example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function $createCustomParagraphNode(): CustomParagraph {\n  return $applyNodeReplacement(new CustomParagraph());\n}\n\nexport function $isCustomParagraphNode(\n  node: LexicalNode | null | undefined\n): node is CustomParagraph  {\n  return node instanceof CustomParagraph;\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"extending-textnode",children:["Extending ",(0,r.jsx)(n.code,{children:"TextNode"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export class ColoredNode extends TextNode {\n  __color: string;\n\n  constructor(text: string, color: string, key?: NodeKey): void {\n    super(text, key);\n    this.__color = color;\n  }\n\n  static getType(): string {\n    return 'colored';\n  }\n\n  static clone(node: ColoredNode): ColoredNode {\n    return new ColoredNode(node.__text, node.__color, node.__key);\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = super.createDOM(config);\n    element.style.color = this.__color;\n    return element;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    const isUpdated = super.updateDOM(prevNode, dom, config);\n    if (prevNode.__color !== this.__color) {\n      dom.style.color = this.__color;\n    }\n    return isUpdated;\n  }\n}\n\nexport function $createColoredNode(text: string, color: string): ColoredNode {\n  return $applyNodeReplacement(new ColoredNode(text, color));\n}\n\nexport function $isColoredNode(\n  node: LexicalNode | null | undefined,\n): node is ColoredNode {\n  return node instanceof ColoredNode;\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"extending-decoratornode",children:["Extending ",(0,r.jsx)(n.code,{children:"DecoratorNode"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export class VideoNode extends DecoratorNode<ReactNode> {\n  __id: string;\n\n  static getType(): string {\n    return 'video';\n  }\n\n  static clone(node: VideoNode): VideoNode {\n    return new VideoNode(node.__id, node.__key);\n  }\n\n  constructor(id: string, key?: NodeKey) {\n    super(key);\n    this.__id = id;\n  }\n\n  createDOM(): HTMLElement {\n    return document.createElement('div');\n  }\n\n  updateDOM(): false {\n    return false;\n  }\n\n  decorate(): ReactNode {\n    return <VideoPlayer videoID={this.__id} />;\n  }\n}\n\nexport function $createVideoNode(id: string): VideoNode {\n  return $applyNodeReplacement(new VideoNode(id));\n}\n\nexport function $isVideoNode(\n  node: LexicalNode | null | undefined,\n): node is VideoNode {\n  return node instanceof VideoNode;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"useDecorators"}),", ",(0,r.jsx)(n.code,{children:"PlainTextPlugin"})," and ",(0,r.jsx)(n.code,{children:"RichTextPlugin"})," executes ",(0,r.jsx)(n.code,{children:"React.createPortal(reactDecorator, element)"})," for each ",(0,r.jsx)(n.code,{children:"DecoratorNode"}),",\nwhere the ",(0,r.jsx)(n.code,{children:"reactDecorator"})," is what is returned by ",(0,r.jsx)(n.code,{children:"DecoratorNode.prototype.decorate"}),",\nand the ",(0,r.jsx)(n.code,{children:"element"})," is an ",(0,r.jsx)(n.code,{children:"HTMLElement"})," returned by ",(0,r.jsx)(n.code,{children:"DecoratorNode.prototype.createDOM"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"the-rest-of-the-boilerplate",children:"The rest of the boilerplate"}),"\n",(0,r.jsx)(n.p,{children:"When using this method of extension, it is also required to implement the\nfollowing methods:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"static clone"})," (always - this is already in the above examples)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"static importFromJSON"})," (always)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"updateFromJSON"})," (if any custom properties are defined)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"afterCloneFrom"})," (if any custom properties are defined that are not carried over from static clone)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"exportJSON"})," (if any custom properties are defined)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"creating-custom-nodes-with-config-and-nodestate",children:"Creating custom nodes with $config and NodeState"}),"\n",(0,r.jsxs)(n.p,{children:["In Lexical v0.33.0, a new method for defining custom nodes was added to reduce\nboilerplate and add features used by the\n",(0,r.jsx)(n.a,{href:"/docs/concepts/node-state",children:"NodeState"})," API."]}),"\n",(0,r.jsx)(n.p,{children:"The following section shows how the previous examples would be refactored to\nuse the latest functionality, reducing boilerplate."}),"\n",(0,r.jsxs)(n.p,{children:["Note that since these example use NodeState and ",(0,r.jsx)(n.code,{children:"$config"}),", they will\nautomatically get full and correct implementations of the following methods:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"static clone"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"static importFromJSON"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"updateFromJSON"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"afterCloneFrom"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"exportJSON"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The constructor of any custom node must have zero required arguments.\nThis is required for ",(0,r.jsx)(n.code,{children:"@lexical/yjs"})," support, ",(0,r.jsx)(n.code,{children:"$create"})," support, and allows the\nboilerplate static ",(0,r.jsx)(n.code,{children:"clone"})," and ",(0,r.jsx)(n.code,{children:"importJSON"})," methods to be eliminated."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.code,{children:"constructor(text: string = '', key?: NodeKey)"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u274C ",(0,r.jsx)(n.code,{children:"constructor(text: string, key?: NodeKey)"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Using only NodeState (and not direct property access) for storing\nadditional data on the node allows the boilerplate ",(0,r.jsx)(n.code,{children:"afterCloneFrom"}),",\n",(0,r.jsx)(n.code,{children:"exportJSON"}),", and ",(0,r.jsx)(n.code,{children:"updateFromJSON"})," methods to be eliminated."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"extending-elementnode-with-config",children:["Extending ",(0,r.jsx)(n.code,{children:"ElementNode"})," with $config"]}),"\n",(0,r.jsxs)(n.p,{children:["Below is an example of how you might extend ",(0,r.jsx)(n.code,{children:"ElementNode"}),":"]}),"\n",(0,r.jsxs)(d.default,{children:[(0,r.jsx)(s.default,{value:"$config",label:"Using $config",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  $create,\n  type EditorConfig,\n  ElementNode,\n  type LexicalNode,\n} from 'lexical';\n\nexport class CustomParagraph extends ElementNode {\n  // highlight-start\n  $config() {\n    return this.config('custom-paragraph', {extends: ElementNode});\n  }\n  // highlight-end\n\n  createDOM(): HTMLElement {\n    // Define the DOM element here\n    const dom = document.createElement('p');\n    return dom;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    // Returning false tells Lexical that this node does not need its\n    // DOM element replaced with a new one from createDOM.\n    return false;\n  }\n}\n"})})}),(0,r.jsx)(s.default,{value:"legacy",label:"Legacy static methods",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  $create,\n  type EditorConfig,\n  ElementNode,\n  type LexicalNode,\n  // highlight-next-line\n  type SerializedLexicalNode,\n} from 'lexical';\n\nexport class CustomParagraph extends ElementNode {\n  // highlight-start\n  static getType(): string {\n    return 'custom-paragraph';\n  }\n\n  static clone(node: CustomParagraph): CustomParagraph {\n    return new CustomParagraph(node.__key);\n  }\n\n  static importJSON(serializedNode: SerializedLexicalNode): CustomParagraph {\n    return new CustomParagraph().updateFromJSON(serializedNode);\n  }\n  // highlight-end\n\n  createDOM(): HTMLElement {\n    // Define the DOM element here\n    const dom = document.createElement('p');\n    return dom;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    // Returning false tells Lexical that this node does not need its\n    // DOM element replacing with a new copy from createDOM.\n    return false;\n  }\n}\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["It's also good etiquette to provide some ",(0,r.jsx)(n.code,{children:"$"})," prefixed utility functions for\nyour custom ",(0,r.jsx)(n.code,{children:"ElementNode"})," so that others can easily consume and validate nodes\nare that of your custom node. Here's how you might do this for the above example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function $createCustomParagraphNode(): CustomParagraph {\n  return $create(CustomParagraph);\n}\n\nexport function $isCustomParagraphNode(\n  node: LexicalNode | null | undefined\n): node is CustomParagraph  {\n  return node instanceof CustomParagraph;\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"extending-textnode-with-config",children:["Extending ",(0,r.jsx)(n.code,{children:"TextNode"})," with $config"]}),"\n",(0,r.jsxs)(d.default,{children:[(0,r.jsx)(s.default,{value:"$config",label:"Using $config",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  // highlight-start\n  $create,\n  $getState,\n  $getStateChange,\n  $setState,\n  // highlight-end\n  type EditorConfig,\n  type LexicalNode,\n  TextNode,\n  // highlight-next-line\n  createState,\n} from 'lexical';\n\nconst DEFAULT_COLOR = 'inherit';\n\n// highlight-start\n// This defines how the color property is parsed along with a default value\nconst colorState = createState('color', {\n  parse: (value) => (typeof value === 'string' ? value : DEFAULT_COLOR),\n});\n// highlight-end\n\nexport class ColoredNode extends TextNode {\n  // highlight-start\n  $config() {\n    return this.config('colored', {\n      extends: TextNode,\n      // This defines the serialization of the color NodeState as\n      // a flat property of the SerializedLexicalNode JSON instead of\n      // nesting it in the '$' property\n      stateConfigs: [{flat: true, stateConfig: colorState}],\n    });\n  }\n  // highlight-end\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = super.createDOM(config);\n    // highlight-next-line\n    element.style.color = $getState(this, colorState);\n    return element;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    if (super.updateDOM(prevNode, dom, config)) {\n      return true;\n    }\n    // highlight-start\n    const colorChange = $getStateChange(this, prevNode, colorState);\n    if (colorChange !== null) {\n      dom.style.color = colorChange[0];\n    }\n    // highlight-end\n    return false;\n  }\n}\n\n// highlight-start\nexport function $createColoredNode(text: string, color: string): ColoredNode {\n  // Since our constructor has 0 arguments, we set all of its properties\n  // after construction.\n  return $setState($create(ColoredNode).setText(text), colorState, color);\n}\n// highlight-end\n\nexport function $isColoredNode(\n  node: LexicalNode | null | undefined,\n): node is ColoredNode {\n  return node instanceof ColoredNode;\n}\n"})})}),(0,r.jsx)(s.default,{value:"legacy",label:"Legacy static methods and properties",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  // highlight-next-line\n  $applyNodeReplacement,\n  type EditorConfig,\n  type LexicalNode,\n  // highlight-start\n  type SerializedTextNode,\n  type Spread,\n  // highlight-end\n  TextNode,\n} from 'lexical';\n\nconst DEFAULT_COLOR = 'inherit';\n\n// highlight-start\nexport type SerializedColoredNode = Spread<\n  {\n    color?: string;\n  },\n  SerializedTextNode\n>;\n// highlight-end\n\nexport class ColoredNode extends TextNode {\n  // highlight-start\n  __color: string;\n\n  constructor(\n    text: string = '',\n    color: string = DEFAULT_COLOR,\n    key?: NodeKey,\n  ): void {\n    super(text, key);\n    this.__color = color;\n  }\n\n  static getType(): string {\n    return 'colored';\n  }\n\n  static clone(node: ColoredNode): ColoredNode {\n    return new ColoredNode(node.__text, node.__color, node.__key);\n  }\n\n  static importFromJSON(serializedNode: SerializedColoredNode) {\n    return new ColoredNode().updateFromJSON(serializedNode);\n  }\n\n  updateFromJSON(serializedNode: SerializedColoredNode) {\n    const self = super.updateFromJSON(serializedNode);\n    self.__color =\n      typeof serializedNode.color === 'string'\n        ? serializedNode.color\n        : DEFAULT_COLOR;\n    return self;\n  }\n\n  exportJSON(): SerializedColoredNode {\n    return {\n      ...super.exportJSON(),\n      color: this.__color === DEFAULT_COLOR ? undefined : this.__color,\n    };\n  }\n  // highlight-end\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = super.createDOM(config);\n    // highlight-next-line\n    element.style.color = this.__color;\n    return element;\n  }\n\n  updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {\n    if (super.updateDOM(prevNode, dom, config)) {\n      return true;\n    }\n    // highlight-start\n    if (prevNode.__color !== this.__color) {\n      dom.style.color = this.__color;\n    }\n    // highlight-end\n    return false;\n  }\n}\n\nexport function $createColoredNode(text: string, color: string): ColoredNode {\n  // highlight-next-line\n  return $applyNodeReplacement(new ColoredNode(text, color));\n}\n\nexport function $isColoredNode(\n  node: LexicalNode | null | undefined,\n): node is ColoredNode {\n  return node instanceof ColoredNode;\n}\n"})})})]}),"\n",(0,r.jsxs)(n.h3,{id:"extending-decoratornode-using-config",children:["Extending ",(0,r.jsx)(n.code,{children:"DecoratorNode"})," using $config"]}),"\n",(0,r.jsxs)(d.default,{children:[(0,r.jsx)(s.default,{value:"$config",label:"Using $config",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  // highlight-start\n  $create,\n  $getState,\n  $getStateChange,\n  $setState,\n  // highlight-end\n  DecoratorNode,\n  type EditorConfig,\n  type LexicalNode,\n  // highlight-next-line\n  createState,\n} from 'lexical';\n\n// highlight-start\nconst idState = createState('id', {\n  parse: (value) => (typeof value === 'string' ? value : ''),\n});\n// highlight-end\n\nexport class VideoNode extends DecoratorNode<ReactNode> {\n  // highlight-start\n  $config() {\n    return this.config('video', {\n      extends: DecoratorNode,\n      stateConfigs: [{flat: true, stateConfig: idState}],\n    });\n  }\n  // highlight-end\n\n  createDOM(): HTMLElement {\n    return document.createElement('div');\n  }\n\n  updateDOM(): false {\n    return false;\n  }\n\n  decorate(): ReactNode {\n    // highlight-next-line\n    return <VideoPlayer videoID={$getState(this, idState)} />;\n  }\n}\n\nexport function $createVideoNode(id: string): VideoNode {\n  // highlight-next-line\n  return $setState($create(VideoNode), idState, id);\n}\n\nexport function $isVideoNode(\n  node: LexicalNode | null | undefined,\n): node is VideoNode {\n  return node instanceof VideoNode;\n}\n"})})}),(0,r.jsx)(s.default,{value:"legacy",label:"Legacy static methods and properties",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\n  DecoratorNode,\n  type EditorConfig,\n  type LexicalNode,\n  // highlight-start\n  type SerializedLexicalNode,\n  type Spread,\n  // highlight-end\n} from 'lexical';\n\n// highlight-start\nexport type SerializedVideoNode = Spread<\n  {\n    id: string;\n  },\n  SerializedLexicalNode\n>;\n// highlight-end\n\nexport class VideoNode extends DecoratorNode<ReactNode> {\n  // highlight-start\n  __id: string;\n\n  static getType(): string {\n    return 'video';\n  }\n\n  static clone(node: VideoNode): VideoNode {\n    return new VideoNode(node.__id, node.__key);\n  }\n\n  static importJSON(serializedNode: SerializedVideoNode): VideoNode {\n    return new VideoNode(serializedNode.id).updateFromJSON(serializedNode);\n  }\n\n  constructor(id: string, key?: NodeKey) {\n    super(key);\n    this.__id = id;\n  }\n\n  exportJSON(): SerializedVideoNode {\n    return {...super.exportJSON(), id: this.__id};\n  }\n  // highlight-end\n\n  createDOM(): HTMLElement {\n    return document.createElement('div');\n  }\n\n  updateDOM(): false {\n    return false;\n  }\n\n  decorate(): ReactNode {\n    return <VideoPlayer videoID={this.__id} />;\n  }\n}\n\nexport function $createVideoNode(id: string): VideoNode {\n  // highlight-next-line\n  return $applyNodeReplacement(new VideoNode(id));\n}\n\nexport function $isVideoNode(\n  node: LexicalNode | null | undefined,\n): node is VideoNode {\n  return node instanceof VideoNode;\n}\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"useDecorators"}),", ",(0,r.jsx)(n.code,{children:"PlainTextPlugin"})," and ",(0,r.jsx)(n.code,{children:"RichTextPlugin"})," executes ",(0,r.jsx)(n.code,{children:"React.createPortal(reactDecorator, element)"})," for each ",(0,r.jsx)(n.code,{children:"DecoratorNode"}),",\nwhere the ",(0,r.jsx)(n.code,{children:"reactDecorator"})," is what is returned by ",(0,r.jsx)(n.code,{children:"DecoratorNode.prototype.decorate"}),",\nand the ",(0,r.jsx)(n.code,{children:"element"})," is an ",(0,r.jsx)(n.code,{children:"HTMLElement"})," returned by ",(0,r.jsx)(n.code,{children:"DecoratorNode.prototype.createDOM"}),"."]})]})}function x(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},84828:function(e,n,t){t.r(n),t.d(n,{default:()=>i});var o=t(52322);t(2784);var r=t(67239);function i(e){let{children:n,hidden:t,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.Z)("tabItem_OMyP",i),hidden:t,children:n})}},83929:function(e,n,t){t.r(n),t.d(n,{default:()=>N});var o=t(52322),r=t(2784),i=t(67239),d=t(84813),s=t(7267),a=t(78142),l=t(92174),c=t(24005),h=t(31823);function u(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function x(e){let{value:n,tabValues:t}=e;return t.some(e=>e.value===n)}var p=t(49761);function g(e){let{className:n,block:t,selectedValue:r,selectValue:s,tabValues:a}=e,l=[],{blockElementScrollPositionUntilNextRender:c}=(0,d.o5)(),h=e=>{let n=e.currentTarget,t=a[l.indexOf(n)].value;t!==r&&(c(n),s(t))},u=e=>{let n=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{let t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{let t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1]}}n?.focus()};return(0,o.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n),children:a.map(e=>{let{value:n,label:t,attributes:d}=e;return(0,o.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>{l.push(e)},onKeyDown:u,onClick:h,...d,className:(0,i.Z)("tabs__item","tabItem_ysIP",d?.className,{"tabs__item--active":r===n}),children:t??n},n)})})}function m(e){let{lazy:n,children:t,selectedValue:d}=e,s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){let e=s.find(e=>e.props.value===d);return e?(0,r.cloneElement)(e,{className:(0,i.Z)("margin-top--md",e.props.className)}):null}return(0,o.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==d}))})}function f(e){let n=function(e){let{defaultValue:n,queryString:t=!1,groupId:o}=e,i=function(e){let{values:n,children:t}=e;return(0,r.useMemo)(()=>{let e=n??u(t).map(e=>{let{props:{value:n,label:t,attributes:o,default:r}}=e;return{value:n,label:t,attributes:o,default:r}}),o=(0,c.lx)(e,(e,n)=>e.value===n.value);if(o.length>0)throw Error(`Docusaurus error: Duplicate values "${o.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,t])}(e),[d,p]=(0,r.useState)(()=>(function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!x({value:n,tabValues:t}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}let o=t.find(e=>e.default)??t[0];if(!o)throw Error("Unexpected error: 0 tabValues");return o.value})({defaultValue:n,tabValues:i})),[g,m]=function(e){let{queryString:n=!1,groupId:t}=e,o=(0,s.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l._X)(i),(0,r.useCallback)(e=>{if(!i)return;let n=new URLSearchParams(o.location.search);n.set(i,e),o.replace({...o.location,search:n.toString()})},[i,o])]}({queryString:t,groupId:o}),[f,N]=function(e){let{groupId:n}=e,t=n?`docusaurus.tab.${n}`:null,[o,i]=(0,h.Nk)(t);return[o,(0,r.useCallback)(e=>{t&&i.set(e)},[t,i])]}({groupId:o}),j=(()=>{let e=g??f;return x({value:e,tabValues:i})?e:null})();return(0,a.Z)(()=>{j&&p(j)},[j]),{selectedValue:d,selectValue:(0,r.useCallback)(e=>{if(!x({value:e,tabValues:i}))throw Error(`Can't select invalid tab value=${e}`);p(e),m(e),N(e)},[m,N,i]),tabValues:i}}(e);return(0,o.jsxs)("div",{className:(0,i.Z)("tabs-container","tabList_M0Dn"),children:[(0,o.jsx)(g,{...n,...e}),(0,o.jsx)(m,{...n,...e})]})}function N(e){let n=(0,p.default)();return(0,o.jsx)(f,{...e,children:u(e.children)},String(n))}},22840:function(e,n,t){t.d(n,{Z:()=>s,a:()=>d});var o=t(2784);let r={},i=o.createContext(r);function d(e){let n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);