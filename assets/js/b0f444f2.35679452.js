"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["9067"],{65994:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>r,default:()=>o,contentTitle:()=>d,assets:()=>c,toc:()=>h,metadata:()=>l});var l=JSON.parse('{"id":"api/modules/lexical_text","title":"Module: @lexical/text","description":"Type Aliases","source":"@site/docs/api/modules/lexical_text.md","sourceDirName":"api/modules","slug":"/api/modules/lexical_text","permalink":"/docs/api/modules/lexical_text","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"id":"lexical_text","title":"Module: @lexical/text","custom_edit_url":null},"sidebar":"api","previous":{"title":"@lexical/table","permalink":"/docs/api/modules/lexical_table"},"next":{"title":"@lexical/utils","permalink":"/docs/api/modules/lexical_utils"}}'),i=n(52322),s=n(22840);let r={id:"lexical_text",title:"Module: @lexical/text",custom_edit_url:null},d=void 0,c={},h=[{value:"Type Aliases",id:"type-aliases",level:2},{value:"EntityMatch",id:"entitymatch",level:3},{value:"Type declaration",id:"type-declaration",level:4},{value:"Defined in",id:"defined-in",level:4},{value:"TextNodeWithOffset",id:"textnodewithoffset",level:3},{value:"Type declaration",id:"type-declaration-1",level:4},{value:"Defined in",id:"defined-in-1",level:4},{value:"Functions",id:"functions",level:2},{value:"$canShowPlaceholder",id:"canshowplaceholder",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Defined in",id:"defined-in-2",level:4},{value:"$canShowPlaceholderCurry",id:"canshowplaceholdercurry",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Returns",id:"returns-2",level:5},{value:"Defined in",id:"defined-in-3",level:4},{value:"$findTextIntersectionFromCharacters",id:"findtextintersectionfromcharacters",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-3",level:4},{value:"Defined in",id:"defined-in-4",level:4},{value:"$isRootTextContentEmpty",id:"isroottextcontentempty",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-4",level:4},{value:"Defined in",id:"defined-in-5",level:4},{value:"$isRootTextContentEmptyCurry",id:"isroottextcontentemptycurry",level:3},{value:"Parameters",id:"parameters-4",level:4},{value:"Returns",id:"returns-5",level:4},{value:"Returns",id:"returns-6",level:5},{value:"Defined in",id:"defined-in-6",level:4},{value:"$rootTextContent",id:"roottextcontent",level:3},{value:"Returns",id:"returns-7",level:4},{value:"Defined in",id:"defined-in-7",level:4},{value:"registerLexicalTextEntity",id:"registerlexicaltextentity",level:3},{value:"Type parameters",id:"type-parameters",level:4},{value:"Parameters",id:"parameters-5",level:4},{value:"Returns",id:"returns-8",level:4},{value:"Defined in",id:"defined-in-8",level:4}];function x(e){let t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"type-aliases",children:"Type Aliases"}),"\n",(0,i.jsx)(t.h3,{id:"entitymatch",children:"EntityMatch"}),"\n",(0,i.jsxs)(t.p,{children:["\u01AC ",(0,i.jsx)(t.strong,{children:"EntityMatch"}),": ",(0,i.jsx)(t.code,{children:"Object"})]}),"\n",(0,i.jsx)(t.h4,{id:"type-declaration",children:"Type declaration"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"end"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"number"})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"start"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"number"})})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"defined-in",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/registerLexicalTextEntity.ts#L19",children:"packages/lexical-text/src/registerLexicalTextEntity.ts:19"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"textnodewithoffset",children:"TextNodeWithOffset"}),"\n",(0,i.jsxs)(t.p,{children:["\u01AC ",(0,i.jsx)(t.strong,{children:"TextNodeWithOffset"}),": ",(0,i.jsx)(t.code,{children:"Object"})]}),"\n",(0,i.jsx)(t.h4,{id:"type-declaration-1",children:"Type declaration"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"node"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.TextNode",children:(0,i.jsx)(t.code,{children:"TextNode"})})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"offset"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"number"})})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-1",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/index.ts#L11",children:"packages/lexical-text/src/index.ts:11"})}),"\n",(0,i.jsx)(t.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(t.h3,{id:"canshowplaceholder",children:"$canShowPlaceholder"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"$canShowPlaceholder"}),"(",(0,i.jsx)(t.code,{children:"isComposing"}),"): ",(0,i.jsx)(t.code,{children:"boolean"})]}),"\n",(0,i.jsx)(t.p,{children:"Determines if the input should show the placeholder. If anything is in\nin the root the placeholder should not be shown."}),"\n",(0,i.jsx)(t.h4,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"isComposing"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Is the editor in composition mode due to an active Input Method Editor?"})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"returns",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"boolean"})}),"\n",(0,i.jsx)(t.p,{children:"true if the input should show the placeholder, false otherwise."}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-2",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/canShowPlaceholder.ts#L24",children:"packages/lexical-text/src/canShowPlaceholder.ts:24"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"canshowplaceholdercurry",children:"$canShowPlaceholderCurry"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"$canShowPlaceholderCurry"}),"(",(0,i.jsx)(t.code,{children:"isEditorComposing"}),"): () => ",(0,i.jsx)(t.code,{children:"boolean"})]}),"\n",(0,i.jsxs)(t.p,{children:["Returns a function that executes ",(0,i.jsx)(t.a,{href:"/docs/api/modules/lexical_text#canshowplaceholder",children:"$canShowPlaceholder"})]}),"\n",(0,i.jsx)(t.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"isEditorComposing"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Is the editor in composition mode due to an active Input Method Editor?"})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"returns-1",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"fn"})}),"\n",(0,i.jsx)(t.p,{children:"A function that executes $canShowPlaceholder with arguments."}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 (): ",(0,i.jsx)(t.code,{children:"boolean"})]}),"\n",(0,i.jsx)(t.h5,{id:"returns-2",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"boolean"})}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-3",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/canShowPlaceholder.ts#L74",children:"packages/lexical-text/src/canShowPlaceholder.ts:74"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"findtextintersectionfromcharacters",children:"$findTextIntersectionFromCharacters"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"$findTextIntersectionFromCharacters"}),"(",(0,i.jsx)(t.code,{children:"root"}),", ",(0,i.jsx)(t.code,{children:"targetCharacters"}),"): ",(0,i.jsx)(t.code,{children:"null"})," | { ",(0,i.jsx)(t.code,{children:"node"}),": ",(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.TextNode",children:(0,i.jsx)(t.code,{children:"TextNode"})})," ; ",(0,i.jsx)(t.code,{children:"offset"}),": ",(0,i.jsx)(t.code,{children:"number"}),"  }"]}),"\n",(0,i.jsx)(t.p,{children:"Finds a TextNode with a size larger than targetCharacters and returns\nthe node along with the remaining length of the text."}),"\n",(0,i.jsx)(t.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"root"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.RootNode",children:(0,i.jsx)(t.code,{children:"RootNode"})})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"The RootNode."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"targetCharacters"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"number"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"The number of characters whose TextNode must be larger than."})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"returns-3",children:"Returns"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"null"})," | { ",(0,i.jsx)(t.code,{children:"node"}),": ",(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.TextNode",children:(0,i.jsx)(t.code,{children:"TextNode"})})," ; ",(0,i.jsx)(t.code,{children:"offset"}),": ",(0,i.jsx)(t.code,{children:"number"}),"  }"]}),"\n",(0,i.jsx)(t.p,{children:"The TextNode and the intersections offset, or null if no TextNode is found."}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-4",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/findTextIntersectionFromCharacters.ts#L17",children:"packages/lexical-text/src/findTextIntersectionFromCharacters.ts:17"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"isroottextcontentempty",children:"$isRootTextContentEmpty"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"$isRootTextContentEmpty"}),"(",(0,i.jsx)(t.code,{children:"isEditorComposing"}),", ",(0,i.jsx)(t.code,{children:"trim?"}),"): ",(0,i.jsx)(t.code,{children:"boolean"})]}),"\n",(0,i.jsx)(t.p,{children:"Determines if the root has any text content and can trim any whitespace if it does."}),"\n",(0,i.jsx)(t.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Default value"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"isEditorComposing"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"undefined"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Is the editor in composition mode due to an active Input Method Editor?"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"trim"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"true"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Should the root text have its whitespaced trimmed? Defaults to true."})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"returns-4",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"boolean"})}),"\n",(0,i.jsx)(t.p,{children:"true if text content is empty, false if there is text or isEditorComposing is true."}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-5",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/isRootTextContentEmpty.ts#L16",children:"packages/lexical-text/src/isRootTextContentEmpty.ts:16"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"isroottextcontentemptycurry",children:"$isRootTextContentEmptyCurry"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"$isRootTextContentEmptyCurry"}),"(",(0,i.jsx)(t.code,{children:"isEditorComposing"}),", ",(0,i.jsx)(t.code,{children:"trim?"}),"): () => ",(0,i.jsx)(t.code,{children:"boolean"})]}),"\n",(0,i.jsxs)(t.p,{children:["Returns a function that executes ",(0,i.jsx)(t.a,{href:"/docs/api/modules/lexical_text#isroottextcontentempty",children:"$isRootTextContentEmpty"})]}),"\n",(0,i.jsx)(t.h4,{id:"parameters-4",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"isEditorComposing"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Is the editor in composition mode due to an active Input Method Editor?"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"trim?"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"boolean"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Should the root text have its whitespaced trimmed? Defaults to true."})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"returns-5",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"fn"})}),"\n",(0,i.jsx)(t.p,{children:"A function that executes $isRootTextContentEmpty based on arguments."}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 (): ",(0,i.jsx)(t.code,{children:"boolean"})]}),"\n",(0,i.jsx)(t.h5,{id:"returns-6",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"boolean"})}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-6",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/isRootTextContentEmpty.ts#L39",children:"packages/lexical-text/src/isRootTextContentEmpty.ts:39"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"roottextcontent",children:"$rootTextContent"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"$rootTextContent"}),"(): ",(0,i.jsx)(t.code,{children:"string"})]}),"\n",(0,i.jsx)(t.p,{children:"Returns the root's text content."}),"\n",(0,i.jsx)(t.h4,{id:"returns-7",children:"Returns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"string"})}),"\n",(0,i.jsx)(t.p,{children:"The root's text content."}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-7",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/rootTextContent.ts#L14",children:"packages/lexical-text/src/rootTextContent.ts:14"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h3,{id:"registerlexicaltextentity",children:"registerLexicalTextEntity"}),"\n",(0,i.jsxs)(t.p,{children:["\u25B8 ",(0,i.jsx)(t.strong,{children:"registerLexicalTextEntity"}),"<",(0,i.jsx)(t.code,{children:"T"}),">(",(0,i.jsx)(t.code,{children:"editor"}),", ",(0,i.jsx)(t.code,{children:"getMatch"}),", ",(0,i.jsx)(t.code,{children:"targetNode"}),", ",(0,i.jsx)(t.code,{children:"createNode"}),"): () => ",(0,i.jsx)(t.code,{children:"void"}),"[]"]}),"\n",(0,i.jsx)(t.p,{children:"Returns a tuple that can be rested (...) into mergeRegister to clean up\nnode transforms listeners that transforms text into another node, eg. a HashtagNode."}),"\n",(0,i.jsx)(t.h4,{id:"type-parameters",children:"Type parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"T"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["extends ",(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.TextNode",children:(0,i.jsx)(t.code,{children:"TextNode"})})]})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"parameters-5",children:"Parameters"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"editor"})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.LexicalEditor",children:(0,i.jsx)(t.code,{children:"LexicalEditor"})})}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"The lexical editor."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"getMatch"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["(",(0,i.jsx)(t.code,{children:"text"}),": ",(0,i.jsx)(t.code,{children:"string"}),") => ",(0,i.jsx)(t.code,{children:"null"})," | ",(0,i.jsx)(t.a,{href:"/docs/api/modules/lexical_text#entitymatch",children:(0,i.jsx)(t.code,{children:"EntityMatch"})})]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Finds a matching string that satisfies a regex expression."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"targetNode"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,i.jsx)(t.a,{href:"/docs/api/modules/lexical#klass",children:(0,i.jsx)(t.code,{children:"Klass"})}),"<",(0,i.jsx)(t.code,{children:"T"}),">"]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"The node type that contains text to match with. eg. HashtagNode"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:(0,i.jsx)(t.code,{children:"createNode"})}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["(",(0,i.jsx)(t.code,{children:"textNode"}),": ",(0,i.jsx)(t.a,{href:"/docs/api/classes/lexical.TextNode",children:(0,i.jsx)(t.code,{children:"TextNode"})}),") => ",(0,i.jsx)(t.code,{children:"T"})]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"A function that creates a new node to contain the matched text. eg createHashtagNode"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"returns-8",children:"Returns"}),"\n",(0,i.jsxs)(t.p,{children:["() => ",(0,i.jsx)(t.code,{children:"void"}),"[]"]}),"\n",(0,i.jsx)(t.p,{children:"An array containing the plain text and reverse node transform listeners."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"Example"})})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"  useEffect(() => {\n   return mergeRegister(\n     ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n   );\n }, [createNode, editor, getMatch, targetNode]);\n"})}),"\n",(0,i.jsx)(t.p,{children:"Where targetNode is the type of node containing the text you want to transform (like a text input),\nthen getMatch uses a regex to find a matching text and creates the proper node to include the matching text."}),"\n",(0,i.jsx)(t.h4,{id:"defined-in-8",children:"Defined in"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical-text/src/registerLexicalTextEntity.ts#L40",children:"packages/lexical-text/src/registerLexicalTextEntity.ts:40"})})]})}function o(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}},22840:function(e,t,n){n.d(t,{Z:()=>d,a:()=>r});var l=n(2784);let i={},s=l.createContext(i);function r(e){let t=l.useContext(s);return l.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(s.Provider,{value:t},e.children)}}}]);