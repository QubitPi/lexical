"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["6587"],{36692:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>a,default:()=>h,contentTitle:()=>o,assets:()=>l,toc:()=>d,metadata:()=>t});var t=JSON.parse('{"id":"concepts/key-management","title":"Key Management","description":"Keys are a fundamental concept in Lexical that enable efficient state management and node tracking. Understanding how keys work is crucial for building reliable editor implementations.","source":"@site/docs/concepts/key-management.md","sourceDirName":"concepts","slug":"/concepts/key-management","permalink":"/docs/concepts/key-management","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/key-management.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"NodeState","permalink":"/docs/concepts/node-state"},"next":{"title":"Node Cloning","permalink":"/docs/concepts/node-cloning"}}'),r=s(52322),i=s(22840);let a={},o="Key Management",l={},d=[{value:"What are Keys?",id:"what-are-keys",level:2},{value:"When to Use <code>__key</code>?",id:"when-to-use-__key",level:2},{value:"\u2705 Correct Usage",id:"-correct-usage",level:3},{value:"\u274C Incorrect Usage",id:"-incorrect-usage",level:3},{value:"How Lexical Uses Keys",id:"how-lexical-uses-keys",level:2},{value:"Diagram",id:"diagram",level:3},{value:"Node Map Structure",id:"node-map-structure",level:3},{value:"Key-Related APIs",id:"key-related-apis",level:3},{value:"Key Lifecycle",id:"key-lifecycle",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Testing Considerations",id:"testing-considerations",level:2},{value:"Performance Impact",id:"performance-impact",level:2},{value:"Common Questions",id:"common-questions",level:2}];function c(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"key-management",children:"Key Management"})}),"\n",(0,r.jsx)(n.p,{children:"Keys are a fundamental concept in Lexical that enable efficient state management and node tracking. Understanding how keys work is crucial for building reliable editor implementations."}),"\n",(0,r.jsx)(n.h2,{id:"what-are-keys",children:"What are Keys?"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"__key"})," property is a unique identifier assigned to each node in the Lexical editor. These keys are:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically generated by Lexical"}),"\n",(0,r.jsx)(n.li,{children:"Used to track nodes in the editor state"}),"\n",(0,r.jsx)(n.li,{children:"Essential for state management and updates"}),"\n",(0,r.jsx)(n.li,{children:"Immutable during a node's lifecycle"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"when-to-use-__key",children:["When to Use ",(0,r.jsx)(n.code,{children:"__key"}),"?"]}),"\n",(0,r.jsx)(n.h3,{id:"-correct-usage",children:"\u2705 Correct Usage"}),"\n",(0,r.jsx)(n.p,{children:"Keys should ONLY be used in two specific situations:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"In Node Constructors"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class MyCustomNode extends ElementNode {\n  constructor(someData: string, key?: NodeKey) {\n    super(key); // Correctly passing key to parent constructor\n    this.__someData = someData;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"In Static Clone Methods"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class MyCustomNode extends ElementNode {\n  static clone(node: MyCustomNode): MyCustomNode {\n    return new MyCustomNode(node.__someData, node.__key);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"-incorrect-usage",children:"\u274C Incorrect Usage"}),"\n",(0,r.jsx)(n.p,{children:"Never use keys in these situations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274C Don't pass keys between different nodes\nconst newNode = new MyCustomNode(existingNode.__key);\n\n// \u274C Don't manipulate keys directly\nnode.__key = 'custom-key';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"how-lexical-uses-keys",children:"How Lexical Uses Keys"}),"\n",(0,r.jsx)(n.h3,{id:"diagram",children:"Diagram"}),"\n",(0,r.jsx)(n.p,{children:"The dotted outlines show nodes that are re-used in a zero-copy fashion from one EditorState to the next"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n  subgraph s0["Initial State"]\n    direction TB\n    m0["NodeMap (v0)"]\n    m0 --\x3e|Key A| n0a["A (v0)"]\n    m0 --\x3e|Key B| n0b["B (v0)"]\n  end\n  subgraph s1["Create Node C"]\n    direction TB\n    style n1a stroke-dasharray: 5 5\n    style n1b stroke-dasharray: 5 5\n    m1["NodeMap (v1)"]\n    m1 --\x3e|Key A| n1a["A (v0)"]\n    m1 --\x3e|Key B| n1b["B (v0)"]\n    m1 --\x3e|Key C| n1c["C (v0)"]\n  end\n  subgraph s2["Update Node A"]\n    direction TB\n    style n2a stroke-dasharray: 5 0\n    style n2b stroke-dasharray: 5 5\n    style n2c stroke-dasharray: 5 5\n    m2["NodeMap (v1)"]\n    m2 --\x3e|Key A| n2a["A (v1)"]\n    m2 --\x3e|Key B| n2b["B (v0)"]\n    m2 --\x3e|Key C| n2c["C (v0)"]\n  end\n  s0 -.-> s1 -.-> s2'}),"\n",(0,r.jsx)(n.h3,{id:"node-map-structure",children:"Node Map Structure"}),"\n",(0,r.jsxs)(n.p,{children:["The EditorState maintains a ",(0,r.jsx)(n.code,{children:"Map<NodeKey, LexicalNode>"})," that tracks all nodes. Nodes refer to each other using keys in their internal pointers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Internal node structure (not for direct usage)\n{\n  __prev: null | NodeKey,\n  __next: null | NodeKey,\n  __parent: null | NodeKey,\n  // __first, __last and __size are only for ElementNode to track its children\n  __first: null | NodeKey,\n  __last: null | NodeKey,\n  __size: number\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"These internal pointers maintain the tree structure and should never be manipulated directly."}),"\n",(0,r.jsx)(n.h3,{id:"key-related-apis",children:"Key-Related APIs"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Editor Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Get node by key\nconst node = editor.getElementByKey(key);\nconst node = $getNodeByKey(key);\n\n// Get latest version of a node\nconst latest = node.getLatest();\n\n// Get mutable version for updates\nconst mutable = node.getWritable();\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-lifecycle",children:"Key Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"NodeKeys are ephemeral and have several important characteristics:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Serialization"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keys are never serialized"}),"\n",(0,r.jsx)(n.li,{children:"New keys are generated when deserializing (from JSON/HTML)"}),"\n",(0,r.jsx)(n.li,{children:"Keys are only meaningful within their EditorState instance"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Uniqueness"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keys are unique within an EditorState"}),"\n",(0,r.jsx)(n.li,{children:"Current implementation uses serial numbers for debugging"}),"\n",(0,r.jsx)(n.li,{children:"Should be treated as random and opaque values"}),"\n",(0,r.jsx)(n.li,{children:"Never logically reused"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Keys are used internally by Lexical to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Track nodes in the editor state"}),"\n",(0,r.jsx)(n.li,{children:"Manage node updates and versions"}),"\n",(0,r.jsx)(n.li,{children:"Maintain referential integrity"}),"\n",(0,r.jsx)(n.li,{children:"Enable efficient state updates"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Reuse"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274C Never do this\nfunction duplicateNode(node: LexicalNode) {\n  return new SameNodeType(data, node.__key);\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Manual Key Assignment"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274C Never do this\nnode.__key = generateCustomKey();\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Incorrect Constructor/Clone Implementation"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274C Never do this - missing key in constructor\nclass MyCustomNode extends ElementNode {\n  constructor(someData: string) {\n    super(); // Missing key parameter\n    this.__someData = someData;\n  }\n}\n\n// \u2705 Correct implementation\nclass MyCustomNode extends ElementNode {\n  __someData: string;\n\n  constructor(someData: string, key?: NodeKey) {\n    super(key);\n    this.__someData = someData;\n  }\n  \n  static clone(node: MyCustomNode): MyCustomNode {\n    return new MyCustomNode(node.__someData, node.__key);\n  }\n\n  afterCloneFrom(prevNode: this): void {\n    super.afterCloneFrom(prevNode);\n    this.__someData = prevNode.__someData;\n  }\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Node Replacement"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u274C Never re-use the key when changing the node class\nconst editorConfig = {\n  nodes: [\n    CustomNodeType,\n    {\n      replace: OriginalNodeType,\n      with: (node: OriginalNodeType) => new CustomNodeType(node.__key),\n      withKlass: CustomNodeType\n    }\n  ]\n};\n\n// \u2705 Correct: Use node replacement configuration\nconst editorConfig = {\n  nodes: [\n    CustomNodeType,\n    {\n      replace: OriginalNodeType,\n      with: (node: OriginalNodeType) => new CustomNodeType(),\n      withKlass: CustomNodeType\n    }\n  ]\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For proper node replacement, see the ",(0,r.jsx)(n.a,{href:"/docs/concepts/node-replacement",children:"Node Replacement guide"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Let Lexical Handle Keys"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {$applyNodeReplacement} from 'lexical';\n\n// Create node helper function\nexport function $createMyCustomNode(data: string): MyCustomNode {\n  return $applyNodeReplacement(new MyCustomNode(data));\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"testing-considerations",children:"Testing Considerations"}),"\n",(0,r.jsx)(n.p,{children:"When writing tests involving node keys:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"test('node creation', async () => {\n  await editor.update(() => {\n    // \u2705 Correct: Create nodes normally\n    const node = new MyCustomNode(\"test\");\n    \n    // \u2705 Correct: Keys are automatically handled\n    expect(node.__key).toBeDefined();\n    expect(node.__key).not.toBe('');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,r.jsx)(n.p,{children:"Understanding key management is crucial for performance:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Keys enable efficient node lookup (O(1))"}),"\n",(0,r.jsx)(n.li,{children:"Proper key usage prevents unnecessary re-renders"}),"\n",(0,r.jsx)(n.li,{children:"Lexical's key system optimizes state updates"}),"\n",(0,r.jsx)(n.li,{children:"Improper key manipulation can cause performance issues"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-questions",children:"Common Questions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Q: How do I reference a node later?"}),"\nA: Store a reference to the node. Conventionally, all node methods will use ",(0,r.jsx)(n.code,{children:"getLatest()"})," or ",(0,r.jsx)(n.code,{children:"getWritable()"})," which will look up the latest version of that node before reading or writing its properties, which is equivalent to using the key but is type-safe (but may cause errors if you try to use a reference to a node that no longer exists). In some situations it may be preferable to use the key directly, which is also fine."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Q: How do I ensure unique nodes?"}),"\nA: Let Lexical handle key generation and management. Focus on node content and structure."]})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},22840:function(e,n,s){s.d(n,{Z:()=>o,a:()=>a});var t=s(2784);let r={},i=t.createContext(r);function a(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);