"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["6024"],{89205:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>r,default:()=>h,contentTitle:()=>a,assets:()=>l,toc:()=>d,metadata:()=>i});var i=JSON.parse('{"id":"faq","title":"FAQ","description":"Why does Lexical use the $ prefix in the name of many of the functions?","source":"@site/docs/faq.md","sourceDirName":".","slug":"/faq","permalink":"/lexical/docs/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/faq.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docs","previous":{"title":"Collaboration FAQ","permalink":"/lexical/docs/collaboration/faq"}}'),o=t(52322),s=t(22840);let r={sidebar_position:7},a="FAQ",l={},d=[{value:"Why does Lexical use the <code>$</code> prefix in the name of many of the functions?",id:"why-does-lexical-use-the--prefix-in-the-name-of-many-of-the-functions",level:2},{value:"When does reconciliation happen?",id:"when-does-reconciliation-happen",level:2},{value:"Why do tests use <code>await editor.update(\u2026)</code>",id:"why-do-tests-use-await-editorupdate",level:2},{value:"How do I listen for user text insertions?",id:"how-do-i-listen-for-user-text-insertions",level:2},{value:"How do I clear the contents of the editor?",id:"how-do-i-clear-the-contents-of-the-editor",level:2},{value:"How do I listen to specific key down events?",id:"how-do-i-listen-to-specific-key-down-events",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"faq",children:"FAQ"})}),"\n",(0,o.jsxs)(n.h2,{id:"why-does-lexical-use-the--prefix-in-the-name-of-many-of-the-functions",children:["Why does Lexical use the ",(0,o.jsx)(n.code,{children:"$"})," prefix in the name of many of the functions?"]}),"\n",(0,o.jsxs)(n.p,{children:["Originally, Lexical didn't have ",(0,o.jsx)(n.code,{children:"$"})," functions, instead these functions were provided to you through callback params:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Mid 2020 API\neditor.update((viewState) => {\n  const getRoot = viewState.getRoot();\n  ..\n});\neditor.addTextTransform((viewState) => {\n  const getRoot = viewState.getRoot();\n  ..\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Internally, this approach raised some negative feedback:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"viewState"})," terminology was confusing. It wasn't really a ",(0,o.jsx)(n.code,{children:"viewState"}),", more like a toolkit to manipulate the ",(0,o.jsx)(n.code,{children:"EditorState"})]}),"\n",(0,o.jsx)(n.li,{children:"For complex updates and transforms devs had to carry params around on many layers"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:['This is when we decided to leverage the "lexical" scope instead to perform ',(0,o.jsx)(n.code,{children:"EditorState"})," manipulation, and the ",(0,o.jsx)(n.code,{children:"$"})," represents just that."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"editor.update(() => ...);\neditor.registerNodeTransform(FooNode, () => ...);\neditor.getEditorState().read(...);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you've used React Hooks before, you can think of ",(0,o.jsx)(n.code,{children:"$"})," functions as being something that follows a similar pattern. These are functions that show their intent as to where they can or cannot be used. This makes it possible for a developer to create their own functions that give the same signal, by simply prefixing the function with the dollar."]}),"\n",(0,o.jsx)(n.p,{children:"Internally, we've found this scales really well and developers get to grips with it in almost no time at all."}),"\n",(0,o.jsx)(n.h2,{id:"when-does-reconciliation-happen",children:"When does reconciliation happen?"}),"\n",(0,o.jsxs)(n.p,{children:["Reconciliation is scheduled with\n",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask",children:"queueMicrotask"}),",\nwhich means that it will happen very soon, but asynchronously. This is similar\nto something like ",(0,o.jsx)(n.code,{children:"setTimeout(reconcile, 0)"})," with a bit more immediacy or\n",(0,o.jsx)(n.code,{children:"Promise.resolve().then(reconcile)"})," with less overhead. This is done so\nthat all of the updates that occur as a result of a single logical event will\nbe batched into one reconciliation."]}),"\n",(0,o.jsxs)(n.p,{children:["You can force a reconciliation to take place synchronously with the discrete\noption to ",(0,o.jsx)(n.code,{children:"editor.update"})," (demonstrated below)."]}),"\n",(0,o.jsxs)(n.h2,{id:"why-do-tests-use-await-editorupdate",children:["Why do tests use ",(0,o.jsx)(n.code,{children:"await editor.update(\u2026)"})]}),"\n",(0,o.jsx)(n.p,{children:"You may notice that many tests look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"await editor.update(updateA);\nawait editor.update(updateB);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["An astute observer would notice that this seems very strange, since\n",(0,o.jsx)(n.code,{children:"editor.update()"})," returns ",(0,o.jsx)(n.code,{children:"void"})," and not ",(0,o.jsx)(n.code,{children:"Promise<void>"}),". However,\nit does happen to work as you would want it to because\nthe implementation of Promise uses the same microtask queue."]}),"\n",(0,o.jsxs)(n.p,{children:["It's not recommended to rely on this in browser code as it could depend on\nimplementation details of the compilers, bundlers, and VM. It's best to stick\nto using the ",(0,o.jsx)(n.code,{children:"discrete"})," or the ",(0,o.jsx)(n.code,{children:"onUpdate"})," callback options to be sure that\nthe reconciliation has taken place."]}),"\n",(0,o.jsx)(n.p,{children:"Ignoring any other microtasks that were scheduled elsewhere,\nit is roughly equivalent to this synchronous code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"editor.update(updateA, {discrete: true});\neditor.update(updateB, {discrete: true});\n"})}),"\n",(0,o.jsx)(n.p,{children:"At a high level, very roughly, the order of operations looks like this:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"editor.update()"})," is called"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"updateA()"})," is called and updates the editor state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"editor.update()"})," schedules a reconciliation microtask and returns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"await"})," schedules a resume microtask and yields control to the task executor"]}),"\n",(0,o.jsx)(n.li,{children:"the reconciliation microtask runs, reconciling the editor state with the DOM"}),"\n",(0,o.jsx)(n.li,{children:"the resume microtask runs"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-do-i-listen-for-user-text-insertions",children:"How do I listen for user text insertions?"}),"\n",(0,o.jsxs)(n.p,{children:["Listening to text insertion events is problematic with content editables in general. It's a common source of bugs due to how\ndifferent browsers and third-party extensions interact with the DOM. Whilst it's possible to use DOM events like ",(0,o.jsx)(n.code,{children:"input"})," and\n",(0,o.jsx)(n.code,{children:"beforeinput"})," to gauge some of the possible cases where a user has inserted text, these are hardly reliable and also don't\ntake into account edge-cases. Instead, Lexical prefers to consider any change as a possible user input, and as such doesn't\nmake a distinction between the cases. This is important for tools like spellcheck, browser extensions, IME, speech-to-text,\nscreen readers and other external tools that often don't reliably trigger a reliable event sequence (some don't even trigger\nany events at all!)."]}),"\n",(0,o.jsx)(n.p,{children:"For those wanting to react to a text change and possibly block/alter the intent, the recommended approach is to use a node\ntransform. This also plays nicely with other sub-systems at play that might also be looking to do the same thing as you."}),"\n",(0,o.jsx)(n.p,{children:"For those who just want to know of the changes, this can be achieved using a text content listener or an editor update listener."}),"\n",(0,o.jsx)(n.h2,{id:"how-do-i-clear-the-contents-of-the-editor",children:"How do I clear the contents of the editor?"}),"\n",(0,o.jsxs)(n.p,{children:["You can go this by calling ",(0,o.jsx)(n.code,{children:"clear()"})," on the RootNode in an update callback:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"editor.update(() => {\n  $getRoot().clear();\n})\n"})}),"\n",(0,o.jsx)(n.h2,{id:"how-do-i-listen-to-specific-key-down-events",children:"How do I listen to specific key down events?"}),"\n",(0,o.jsx)(n.p,{children:"You can leverage Lexical's command listening system. Lexical provides specific commands for many common keyboard operations, such as:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_LEFT_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_RIGHT_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_UP_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_DOWN_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_SPACE_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ENTER_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_BACKSPACE_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_DELETE_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_TAB_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ESCAPE_COMMAND"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {KEY_ENTER_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\n\neditor.registerCommand(KEY_ENTER_COMMAND, (event: KeyboardEvent) => {\n  // Handle enter key presses here\n  return false;\n}, COMMAND_PRIORITY_LOW)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can use the generic ",(0,o.jsx)(n.code,{children:"KEY_DOWN_COMMAND"})," command to listen\nto all keydown events. Do note, that returning ",(0,o.jsx)(n.code,{children:"true"})," in your listener will prevent any\nother key based commands from firing, so in most cases you'll want to return ",(0,o.jsx)(n.code,{children:"false"})," from\nthe command listener."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {KEY_DOWN_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\n\neditor.registerCommand(KEY_DOWN_COMMAND, (event: KeyboardEvent) => {\n  // Handle event here\n  return false;\n}, COMMAND_PRIORITY_LOW)\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["If you do return ",(0,o.jsx)(n.code,{children:"true"})," from any listener with an event payload, you likely\nalso should call ",(0,o.jsx)(n.code,{children:"event.preventDefault()"})," unless your command relies on the\nbrowser's native processing of that event."]})})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},22840:function(e,n,t){t.d(n,{Z:()=>a,a:()=>r});var i=t(2784);let o={},s=i.createContext(o);function r(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);