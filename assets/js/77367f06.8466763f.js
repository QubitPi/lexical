"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["1373"],{83585:function(e,i,n){n.r(i),n.d(i,{frontMatter:()=>d,default:()=>h,contentTitle:()=>r,assets:()=>c,toc:()=>a,metadata:()=>t});var t=JSON.parse('{"id":"api/interfaces/lexical.StaticNodeConfigValue","title":"Interface: StaticNodeConfigValue<T, Type>","description":"lexical.StaticNodeConfigValue","source":"@site/docs/api/interfaces/lexical.StaticNodeConfigValue.md","sourceDirName":"api/interfaces","slug":"/api/interfaces/lexical.StaticNodeConfigValue","permalink":"/docs/api/interfaces/lexical.StaticNodeConfigValue","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","frontMatter":{"id":"lexical.StaticNodeConfigValue","title":"Interface: StaticNodeConfigValue<T, Type>","custom_edit_url":null},"sidebar":"api","previous":{"title":"StateValueConfig","permalink":"/docs/api/interfaces/lexical.StateValueConfig"},"next":{"title":"StepwiseIteratorConfig","permalink":"/docs/api/interfaces/lexical.StepwiseIteratorConfig"}}'),l=n(52322),s=n(22840);let d={id:"lexical.StaticNodeConfigValue",title:"Interface: StaticNodeConfigValue<T, Type>",custom_edit_url:null},r=void 0,c={},a=[{value:"Type parameters",id:"type-parameters",level:2},{value:"Properties",id:"properties",level:2},{value:"$importJSON",id:"importjson",level:3},{value:"Type declaration",id:"type-declaration",level:4},{value:"Parameters",id:"parameters",level:5},{value:"Returns",id:"returns",level:5},{value:"Defined in",id:"defined-in",level:4},{value:"$transform",id:"transform",level:3},{value:"Type declaration",id:"type-declaration-1",level:4},{value:"Parameters",id:"parameters-1",level:5},{value:"Returns",id:"returns-1",level:5},{value:"Defined in",id:"defined-in-1",level:4},{value:"extends",id:"extends",level:3},{value:"Defined in",id:"defined-in-2",level:4},{value:"importDOM",id:"importdom",level:3},{value:"Defined in",id:"defined-in-3",level:4},{value:"stateConfigs",id:"stateconfigs",level:3},{value:"Defined in",id:"defined-in-4",level:4},{value:"type",id:"type",level:3},{value:"Defined in",id:"defined-in-5",level:4}];function o(e){let i={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.a,{href:"/docs/api/modules/lexical",children:"lexical"}),".StaticNodeConfigValue"]}),"\n",(0,l.jsx)(i.p,{children:"EXPERIMENTAL\nThe configuration of a node returned by LexicalNode.$config()"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:(0,l.jsx)(i.code,{children:"Example"})})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-ts",children:"class CustomText extends TextNode {\n  $config() {\n    return this.config('custom-text', {extends: TextNode}};\n  }\n}\n"})}),"\n",(0,l.jsx)(i.h2,{id:"type-parameters",children:"Type parameters"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(i.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{style:{textAlign:"left"},children:(0,l.jsx)(i.code,{children:"T"})}),(0,l.jsxs)(i.td,{style:{textAlign:"left"},children:["extends ",(0,l.jsx)(i.a,{href:"/docs/api/classes/lexical.LexicalNode",children:(0,l.jsx)(i.code,{children:"LexicalNode"})})]})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{style:{textAlign:"left"},children:(0,l.jsx)(i.code,{children:"Type"})}),(0,l.jsxs)(i.td,{style:{textAlign:"left"},children:["extends ",(0,l.jsx)(i.code,{children:"string"})]})]})]})]}),"\n",(0,l.jsx)(i.h2,{id:"properties",children:"Properties"}),"\n",(0,l.jsx)(i.h3,{id:"importjson",children:"$importJSON"}),"\n",(0,l.jsxs)(i.p,{children:["\u2022 ",(0,l.jsx)(i.code,{children:"Optional"})," ",(0,l.jsx)(i.code,{children:"Readonly"})," ",(0,l.jsx)(i.strong,{children:"$importJSON"}),": (",(0,l.jsx)(i.code,{children:"serializedNode"}),": ",(0,l.jsx)(i.a,{href:"/docs/api/modules/lexical#serializedlexicalnode",children:(0,l.jsx)(i.code,{children:"SerializedLexicalNode"})}),") => ",(0,l.jsx)(i.code,{children:"T"})]}),"\n",(0,l.jsx)(i.p,{children:"An alternative to the static importJSON() method\nthat provides better type inference."}),"\n",(0,l.jsx)(i.h4,{id:"type-declaration",children:"Type declaration"}),"\n",(0,l.jsxs)(i.p,{children:["\u25B8 (",(0,l.jsx)(i.code,{children:"serializedNode"}),"): ",(0,l.jsx)(i.code,{children:"T"})]}),"\n",(0,l.jsx)(i.h5,{id:"parameters",children:"Parameters"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(i.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,l.jsx)(i.tbody,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{style:{textAlign:"left"},children:(0,l.jsx)(i.code,{children:"serializedNode"})}),(0,l.jsx)(i.td,{style:{textAlign:"left"},children:(0,l.jsx)(i.a,{href:"/docs/api/modules/lexical#serializedlexicalnode",children:(0,l.jsx)(i.code,{children:"SerializedLexicalNode"})})})]})})]}),"\n",(0,l.jsx)(i.h5,{id:"returns",children:"Returns"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.code,{children:"T"})}),"\n",(0,l.jsx)(i.h4,{id:"defined-in",children:"Defined in"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNode.ts#L116",children:"packages/lexical/src/LexicalNode.ts:116"})}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h3,{id:"transform",children:"$transform"}),"\n",(0,l.jsxs)(i.p,{children:["\u2022 ",(0,l.jsx)(i.code,{children:"Optional"})," ",(0,l.jsx)(i.code,{children:"Readonly"})," ",(0,l.jsx)(i.strong,{children:"$transform"}),": (",(0,l.jsx)(i.code,{children:"node"}),": ",(0,l.jsx)(i.code,{children:"T"}),") => ",(0,l.jsx)(i.code,{children:"void"})]}),"\n",(0,l.jsx)(i.p,{children:"An alternative to the internal static transform() method\nthat provides better type inference."}),"\n",(0,l.jsx)(i.h4,{id:"type-declaration-1",children:"Type declaration"}),"\n",(0,l.jsxs)(i.p,{children:["\u25B8 (",(0,l.jsx)(i.code,{children:"node"}),"): ",(0,l.jsx)(i.code,{children:"void"})]}),"\n",(0,l.jsx)(i.h5,{id:"parameters-1",children:"Parameters"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{style:{textAlign:"left"},children:"Name"}),(0,l.jsx)(i.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,l.jsx)(i.tbody,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{style:{textAlign:"left"},children:(0,l.jsx)(i.code,{children:"node"})}),(0,l.jsx)(i.td,{style:{textAlign:"left"},children:(0,l.jsx)(i.code,{children:"T"})})]})})]}),"\n",(0,l.jsx)(i.h5,{id:"returns-1",children:"Returns"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.code,{children:"void"})}),"\n",(0,l.jsx)(i.h4,{id:"defined-in-1",children:"Defined in"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNode.ts#L111",children:"packages/lexical/src/LexicalNode.ts:111"})}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h3,{id:"extends",children:"extends"}),"\n",(0,l.jsxs)(i.p,{children:["\u2022 ",(0,l.jsx)(i.code,{children:"Optional"})," ",(0,l.jsx)(i.code,{children:"Readonly"})," ",(0,l.jsx)(i.strong,{children:"extends"}),": ",(0,l.jsx)(i.a,{href:"/docs/api/modules/lexical#klassconstructor",children:(0,l.jsx)(i.code,{children:"KlassConstructor"})}),"<typeof ",(0,l.jsx)(i.a,{href:"/docs/api/classes/lexical.LexicalNode",children:(0,l.jsx)(i.code,{children:"LexicalNode"})}),">"]}),"\n",(0,l.jsx)(i.p,{children:"If specified, this must be the exact superclass of the node. It is not\nchecked at compile time and it is provided automatically at runtime."}),"\n",(0,l.jsx)(i.p,{children:"You would want to specify this when you are extending a node that\nhas non-trivial configuration in its $config such\nas required state. If you do not specify this, the inferred\ntypes for your node class might be missing some of that."}),"\n",(0,l.jsx)(i.h4,{id:"defined-in-2",children:"Defined in"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNode.ts#L162",children:"packages/lexical/src/LexicalNode.ts:162"})}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h3,{id:"importdom",children:"importDOM"}),"\n",(0,l.jsxs)(i.p,{children:["\u2022 ",(0,l.jsx)(i.code,{children:"Optional"})," ",(0,l.jsx)(i.code,{children:"Readonly"})," ",(0,l.jsx)(i.strong,{children:"importDOM"}),": ",(0,l.jsx)(i.a,{href:"/docs/api/modules/lexical#domconversionmap",children:(0,l.jsx)(i.code,{children:"DOMConversionMap"})}),"<",(0,l.jsx)(i.code,{children:"HTMLElement"}),">"]}),"\n",(0,l.jsx)(i.p,{children:"An alternative to the static importDOM() method"}),"\n",(0,l.jsx)(i.h4,{id:"defined-in-3",children:"Defined in"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNode.ts#L120",children:"packages/lexical/src/LexicalNode.ts:120"})}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h3,{id:"stateconfigs",children:"stateConfigs"}),"\n",(0,l.jsxs)(i.p,{children:["\u2022 ",(0,l.jsx)(i.code,{children:"Optional"})," ",(0,l.jsx)(i.code,{children:"Readonly"})," ",(0,l.jsx)(i.strong,{children:"stateConfigs"}),": readonly ",(0,l.jsx)(i.code,{children:"RequiredNodeStateConfig"}),"[]"]}),"\n",(0,l.jsx)(i.p,{children:"EXPERIMENTAL"}),"\n",(0,l.jsx)(i.p,{children:"An array of RequiredNodeStateConfig to initialize your node with\nits state requirements. This may be used to configure serialization of\nthat state."}),"\n",(0,l.jsx)(i.p,{children:"This function will be called (at most) once per editor initialization,\ndirectly on your node's prototype. It must not depend on any state\ninitialized in the constructor."}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.strong,{children:(0,l.jsx)(i.code,{children:"Example"})})}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-ts",children:'const flatState = createState("flat", {parse: parseNumber});\nconst nestedState = createState("nested", {parse: parseNumber});\nclass MyNode extends TextNode {\n  $config() {\n    return this.config(\n      \'my-node\',\n      {\n        extends: TextNode,\n        stateConfigs: [\n          { stateConfig: flatState, flat: true},\n          nestedState,\n        ]\n      },\n    );\n  }\n}\n'})}),"\n",(0,l.jsx)(i.h4,{id:"defined-in-4",children:"Defined in"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNode.ts#L152",children:"packages/lexical/src/LexicalNode.ts:152"})}),"\n",(0,l.jsx)(i.hr,{}),"\n",(0,l.jsx)(i.h3,{id:"type",children:"type"}),"\n",(0,l.jsxs)(i.p,{children:["\u2022 ",(0,l.jsx)(i.code,{children:"Optional"})," ",(0,l.jsx)(i.code,{children:"Readonly"})," ",(0,l.jsx)(i.strong,{children:"type"}),": ",(0,l.jsx)(i.code,{children:"Type"})]}),"\n",(0,l.jsx)(i.p,{children:"The exact type of T.getType(), e.g. 'text' - the method itself must\nhave a more generic 'string' type to be compatible wtih subclassing."}),"\n",(0,l.jsx)(i.h4,{id:"defined-in-5",children:"Defined in"}),"\n",(0,l.jsx)(i.p,{children:(0,l.jsx)(i.a,{href:"https://github.com/QubitPi/lexical/tree/main/packages/lexical/src/LexicalNode.ts#L106",children:"packages/lexical/src/LexicalNode.ts:106"})})]})}function h(e={}){let{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},22840:function(e,i,n){n.d(i,{Z:()=>r,a:()=>d});var t=n(2784);let l={},s=t.createContext(l);function d(e){let i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);