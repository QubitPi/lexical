"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["8944"],{82042:function(e,n,o){o.r(n),o.d(n,{frontMatter:()=>s,default:()=>h,contentTitle:()=>d,assets:()=>a,toc:()=>l,metadata:()=>t});var t=JSON.parse('{"id":"concepts/serialization","title":"Serialization & Deserialization","description":"Internally, Lexical maintains the state of a given editor in memory, updating it in response to user inputs. Sometimes, it\'s useful to convert this state into a serialized format in order to transfer it between editors or store it for retrieval at some later time. In order to make this process easier, Lexical provides some APIs that allow Nodes to specify how they should be represented in common serialized formats.","source":"@site/docs/concepts/serialization.md","sourceDirName":"concepts","slug":"/concepts/serialization","permalink":"/lexical/docs/concepts/serialization","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/serialization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"useHistory","permalink":"/lexical/docs/concepts/history"},"next":{"title":"Working with DOM Events","permalink":"/lexical/docs/concepts/dom-events"}}'),i=o(52322),r=o(22840);let s={},d="Serialization & Deserialization",a={},l=[{value:"HTML",id:"html",level:2},{value:"Lexical -&gt; HTML",id:"lexical---html",level:3},{value:"<code>LexicalNode.exportDOM()</code>",id:"lexicalnodeexportdom",level:4},{value:"HTML -&gt; Lexical",id:"html---lexical",level:3},{value:"<code>LexicalNode.importDOM()</code>",id:"lexicalnodeimportdom",level:4},{value:"<code>html</code> Property for Import and Export Configuration",id:"html-property-for-import-and-export-configuration",level:3},{value:"Key Differences from <code>importDOM</code> and <code>exportDOM</code>",id:"key-differences-from-importdom-and-exportdom",level:4},{value:"Type Definitions",id:"type-definitions",level:4},{value:"Example of a use case for the <code>html</code> Property for Import and Export Configuration:",id:"example-of-a-use-case-for-the-html-property-for-import-and-export-configuration",level:4},{value:"Handling extended HTML styling",id:"handling-extended-html-styling",level:3},{value:"JSON",id:"json",level:2},{value:"Lexical -&gt; JSON",id:"lexical---json",level:3},{value:"<code>LexicalNode.exportJSON()</code>",id:"lexicalnodeexportjson",level:4},{value:"<code>LexicalNode.importJSON()</code>",id:"lexicalnodeimportjson",level:4},{value:"<code>LexicalNode.updateFromJSON()</code>",id:"lexicalnodeupdatefromjson",level:4},{value:"Versioning &amp; Breaking Changes",id:"versioning--breaking-changes",level:3},{value:"Dangers of a flat version property",id:"dangers-of-a-flat-version-property",level:3}];function c(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"serialization--deserialization",children:"Serialization & Deserialization"})}),"\n",(0,i.jsx)(n.p,{children:"Internally, Lexical maintains the state of a given editor in memory, updating it in response to user inputs. Sometimes, it's useful to convert this state into a serialized format in order to transfer it between editors or store it for retrieval at some later time. In order to make this process easier, Lexical provides some APIs that allow Nodes to specify how they should be represented in common serialized formats."}),"\n",(0,i.jsx)(n.h2,{id:"html",children:"HTML"}),"\n",(0,i.jsxs)(n.p,{children:["Currently, HTML serialization is primarily used to transfer data between Lexical and non-Lexical editors (such as Google Docs or Quip) via the copy & paste functionality in ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical-clipboard/README.md",children:(0,i.jsx)(n.code,{children:"@lexical/clipboard"})}),", but we also offer generic utilities for converting ",(0,i.jsx)(n.code,{children:"Lexical"})," -> ",(0,i.jsx)(n.code,{children:"HTML"})," and ",(0,i.jsx)(n.code,{children:"HTML"})," -> ",(0,i.jsx)(n.code,{children:"Lexical"})," in our ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical-html/README.md",children:(0,i.jsx)(n.code,{children:"@lexical/html"})})," package."]}),"\n",(0,i.jsx)(n.h3,{id:"lexical---html",children:"Lexical -> HTML"}),"\n",(0,i.jsx)(n.p,{children:"When generating HTML from an editor you can pass in a selection object to narrow it down to a certain section or pass in null to convert the whole editor."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import {$generateHtmlFromNodes} from '@lexical/html';\n\nconst htmlString = $generateHtmlFromNodes(editor, selection | null);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"lexicalnodeexportdom",children:(0,i.jsx)(n.code,{children:"LexicalNode.exportDOM()"})}),"\n",(0,i.jsxs)(n.p,{children:["You can control how a ",(0,i.jsx)(n.code,{children:"LexicalNode"})," is represented as HTML by adding an ",(0,i.jsx)(n.code,{children:"exportDOM()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"exportDOM(editor: LexicalEditor): DOMExportOutput\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When transforming an editor state into HTML, we simply traverse the current editor state (or the selected subset thereof) and call the ",(0,i.jsx)(n.code,{children:"exportDOM"})," method for each Node in order to convert it to an ",(0,i.jsx)(n.code,{children:"HTMLElement"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:['Sometimes, it\'s necessary or useful to do some post-processing after a node has been converted to HTML. For this, we expose the "after" API on ',(0,i.jsx)(n.code,{children:"DOMExportOutput"}),", which allows ",(0,i.jsx)(n.code,{children:"exportDOM"})," to specify a function that should be run after the conversion to an ",(0,i.jsx)(n.code,{children:"HTMLElement"})," has happened."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export type DOMExportOutput = {\n  after?: (generatedElement: ?HTMLElement) => ?HTMLElement,\n  element?: HTMLElement | null,\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"If the element property is null in the return value of exportDOM, that Node will not be represented in the serialized output."}),"\n",(0,i.jsx)(n.h3,{id:"html---lexical",children:"HTML -> Lexical"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import {$generateNodesFromDOM} from '@lexical/html';\n\neditor.update(() => {\n  // In the browser you can use the native DOMParser API to parse the HTML string.\n  const parser = new DOMParser();\n  const dom = parser.parseFromString(htmlString, textHtmlMimeType);\n\n  // Once you have the DOM instance it's easy to generate LexicalNodes.\n  const nodes = $generateNodesFromDOM(editor, dom);\n\n  // Select the root\n  $getRoot().select();\n\n  // Insert them at a selection.\n  $insertNodes(nodes);\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you are running in headless mode, you can do it this way using JSDOM:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import {createHeadlessEditor} from '@lexical/headless';\nimport {$generateNodesFromDOM} from '@lexical/html';\n\n// Once you've generated LexicalNodes from your HTML you can now initialize an editor instance with the parsed nodes.\nconst editorNodes = [] // Any custom nodes you register on the editor\nconst editor = createHeadlessEditor({ ...config, nodes: editorNodes });\n\neditor.update(() => {\n  // In a headless environment you can use a package such as JSDom to parse the HTML string.\n  const dom = new JSDOM(htmlString);\n\n  // Once you have the DOM instance it's easy to generate LexicalNodes.\n  const nodes = $generateNodesFromDOM(editor, dom.window.document);\n\n  // Select the root\n  $getRoot().select();\n\n  // Insert them at a selection.\n  const selection = $getSelection();\n  selection.insertNodes(nodes);\n});\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Remember that state updates are asynchronous, so executing ",(0,i.jsx)(n.code,{children:"editor.getEditorState()"})," immediately afterwards might not return the expected content. To avoid it, ",(0,i.jsxs)(n.a,{href:"https://dio.la/article/lexical-state-updates#discrete-updates",children:["pass ",(0,i.jsx)(n.code,{children:"discrete: true"})," in the ",(0,i.jsx)(n.code,{children:"editor.update"})," method"]}),"."]})}),"\n",(0,i.jsx)(n.h4,{id:"lexicalnodeimportdom",children:(0,i.jsx)(n.code,{children:"LexicalNode.importDOM()"})}),"\n",(0,i.jsxs)(n.p,{children:["You can control how an ",(0,i.jsx)(n.code,{children:"HTMLElement"})," is represented in ",(0,i.jsx)(n.code,{children:"Lexical"})," by adding an ",(0,i.jsx)(n.code,{children:"importDOM()"})," method to your ",(0,i.jsx)(n.code,{children:"LexicalNode"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"static importDOM(): DOMConversionMap | null;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The return value of ",(0,i.jsx)(n.code,{children:"importDOM"})," is a map of the lower case (DOM) ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName",children:"Node.nodeName"})," property to an object that specifies a conversion function and a priority for that conversion. This allows ",(0,i.jsx)(n.code,{children:"LexicalNodes"})," to specify which type of DOM nodes they can convert and what the relative priority of their conversion should be. This is useful in cases where a DOM Node with specific attributes should be interpreted as one type of ",(0,i.jsx)(n.code,{children:"LexicalNode"}),", and otherwise it should be represented as another type of ",(0,i.jsx)(n.code,{children:"LexicalNode"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type DOMConversionMap = Record<\n  string,\n  (node: HTMLElement) => DOMConversion | null\n>;\n\ntype DOMConversion = {\n  conversion: DOMConversionFn;\n  priority: 0 | 1 | 2 | 3 | 4;\n};\n\ntype DOMConversionFn = (element: HTMLElement) => DOMConversionOutput | null;\n\ntype DOMConversionOutput = {\n  after?: (childLexicalNodes: Array<LexicalNode>) => Array<LexicalNode>;\n  forChild?: DOMChildConversion;\n  node: null | LexicalNode | Array<LexicalNode>;\n};\n\ntype DOMChildConversion = (\n  lexicalNode: LexicalNode,\n  parentLexicalNode: LexicalNode | null | undefined,\n) => LexicalNode | null | undefined;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["@lexical/code provides a good example of the usefulness of this design. GitHub uses HTML ",(0,i.jsx)(n.code,{children:"<table>"})," elements to represent the structure of copied code in HTML. If we interpreted all HTML ",(0,i.jsx)(n.code,{children:"<table>"})," elements as literal tables, then code pasted from GitHub would appear in Lexical as a Lexical TableNode. Instead, CodeNode specifies that it can handle ",(0,i.jsx)(n.code,{children:"<table>"})," elements too:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class CodeNode extends ElementNode {\n...\nstatic importDOM(): DOMConversionMap | null {\n  return {\n    ...\n    table: (node: Node) => {\n      if (isGitHubCodeTable(node as HTMLTableElement)) {\n        return {\n          conversion: convertTableElement,\n          priority: 3,\n        };\n      }\n      return null;\n    },\n    ...\n  };\n}\n...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the imported ",(0,i.jsx)(n.code,{children:"<table>"})," doesn't align with the expected GitHub code HTML, then we return null and allow the node to be handled by lower priority conversions."]}),"\n",(0,i.jsxs)(n.p,{children:["Much like ",(0,i.jsx)(n.code,{children:"exportDOM"}),", ",(0,i.jsx)(n.code,{children:"importDOM"})," exposes APIs to allow for post-processing of converted Nodes. The conversion function returns a ",(0,i.jsx)(n.code,{children:"DOMConversionOutput"})," which can specify a function to run for each converted child (forChild) or on all the child nodes after the conversion is complete (after). The key difference here is that ",(0,i.jsx)(n.code,{children:"forChild"})," runs for every deeply nested child node of the current node, whereas ",(0,i.jsx)(n.code,{children:"after"})," will run only once after the transformation of the node and all its children is complete."]}),"\n",(0,i.jsxs)(n.h3,{id:"html-property-for-import-and-export-configuration",children:[(0,i.jsx)(n.code,{children:"html"})," Property for Import and Export Configuration"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"html"})," property in ",(0,i.jsx)(n.code,{children:"CreateEditorArgs"})," provides an alternate way to configure HTML import and export behavior in Lexical without subclassing or node replacement. It includes two properties:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"import"})," - Similar to ",(0,i.jsx)(n.code,{children:"importDOM"}),", it controls how HTML elements are transformed into ",(0,i.jsx)(n.code,{children:"LexicalNodes"}),". However, instead of defining conversions directly on each ",(0,i.jsx)(n.code,{children:"LexicalNode"}),", ",(0,i.jsx)(n.code,{children:"html.import"})," provides a configuration that can be overridden easily in the editor setup."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"export"})," - Similar to ",(0,i.jsx)(n.code,{children:"exportDOM"}),", this property customizes how ",(0,i.jsx)(n.code,{children:"LexicalNodes"})," are serialized into HTML. With ",(0,i.jsx)(n.code,{children:"html.export"}),", users can specify transformations for various nodes collectively, offering a flexible override mechanism that can adapt without needing to extend or replace specific ",(0,i.jsx)(n.code,{children:"LexicalNodes"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"key-differences-from-importdom-and-exportdom",children:["Key Differences from ",(0,i.jsx)(n.code,{children:"importDOM"})," and ",(0,i.jsx)(n.code,{children:"exportDOM"})]}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.code,{children:"importDOM"})," and ",(0,i.jsx)(n.code,{children:"exportDOM"})," allow for highly customized, node-specific conversions by defining them directly within the ",(0,i.jsx)(n.code,{children:"LexicalNode"})," class, the ",(0,i.jsx)(n.code,{children:"html"})," property enables broader, editor-wide configurations. This setup benefits situations where:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent Transformations"}),": You want uniform import/export behavior across different nodes without adjusting each node individually."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No Subclassing Required"}),": Overrides to import and export logic are applied at the editor configuration level, simplifying customization and reducing the need for extensive subclassing."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"type HTMLConfig = {\n  export?: DOMExportOutputMap;  // Optional map defining how nodes are exported to HTML.\n  import?: DOMConversionMap;     // Optional record defining how HTML is converted into nodes.\n};\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"example-of-a-use-case-for-the-html-property-for-import-and-export-configuration",children:["Example of a use case for the ",(0,i.jsx)(n.code,{children:"html"})," Property for Import and Export Configuration:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://stackblitz.com/github/facebook/lexical/tree/main/examples/react-rich?embed=1&file=src%2FApp.tsx&terminalHeight=0&ctl=1&showSidebar=0&devtoolsheight=0&view=preview",children:"Rich text sandbox"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-extended-html-styling",children:"Handling extended HTML styling"}),"\n",(0,i.jsx)(n.p,{children:"Since the TextNode is foundational to all Lexical packages, including the plain text use case. Handling any rich text logic is undesirable. This creates the need to override the TextNode to handle serialization and deserialization of HTML/CSS styling properties to achieve full fidelity between JSON <-> HTML. Since this is a very popular use case, below we are proving a recipe to handle the most common use cases."}),"\n",(0,i.jsx)(n.p,{children:"You need to override the base TextNode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const initialConfig: InitialConfigType = {\n    namespace: 'editor',\n    theme: editorThemeClasses,\n    onError: (error: any) => console.log(error),\n    nodes: [\n      ExtendedTextNode,\n      {\n        replace: TextNode,\n        with: (node: TextNode) => new ExtendedTextNode(node.__text),\n        withKlass: ExtendedTextNode,\n      },\n      ListNode,\n      ListItemNode,\n    ]\n  };\n"})}),"\n",(0,i.jsx)(n.p,{children:"and create a new Extended Text Node plugin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import {\n  $applyNodeReplacement,\n  $isTextNode,\n  DOMConversion,\n  DOMConversionMap,\n  DOMConversionOutput,\n  NodeKey,\n  TextNode,\n  SerializedTextNode,\n  LexicalNode\n} from 'lexical';\n\nexport class ExtendedTextNode extends TextNode {\n  constructor(text: string, key?: NodeKey) {\n    super(text, key);\n  }\n\n  static getType(): string {\n    return 'extended-text';\n  }\n\n  static clone(node: ExtendedTextNode): ExtendedTextNode {\n    return new ExtendedTextNode(node.__text, node.__key);\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    const importers = TextNode.importDOM();\n    return {\n      ...importers,\n      code: () => ({\n        conversion: patchStyleConversion(importers?.code),\n        priority: 1\n      }),\n      em: () => ({\n        conversion: patchStyleConversion(importers?.em),\n        priority: 1\n      }),\n      span: () => ({\n        conversion: patchStyleConversion(importers?.span),\n        priority: 1\n      }),\n      strong: () => ({\n        conversion: patchStyleConversion(importers?.strong),\n        priority: 1\n      }),\n      sub: () => ({\n        conversion: patchStyleConversion(importers?.sub),\n        priority: 1\n      }),\n      sup: () => ({\n        conversion: patchStyleConversion(importers?.sup),\n        priority: 1\n      }),\n    };\n  }\n\n  static importJSON(serializedNode: SerializedTextNode): TextNode {\n    return $createExtendedTextNode().updateFromJSON(serializedNode);\n  }\n\n  isSimpleText() {\n    return this.__type === 'extended-text' && this.__mode === 0;\n  }\n\n  // no need to add exportJSON here, since we are not adding any new properties\n}\n\nexport function $createExtendedTextNode(text: string = ''): ExtendedTextNode {\n  return $applyNodeReplacement(new ExtendedTextNode(text));\n}\n\nexport function $isExtendedTextNode(node: LexicalNode | null | undefined): node is ExtendedTextNode {\n	return node instanceof ExtendedTextNode;\n}\n\nfunction patchStyleConversion(\n  originalDOMConverter?: (node: HTMLElement) => DOMConversion | null\n): (node: HTMLElement) => DOMConversionOutput | null {\n  return (node) => {\n    const original = originalDOMConverter?.(node);\n    if (!original) {\n      return null;\n    }\n    const originalOutput = original.conversion(node);\n\n    if (!originalOutput) {\n      return originalOutput;\n    }\n\n    const backgroundColor = node.style.backgroundColor;\n    const color = node.style.color;\n    const fontFamily = node.style.fontFamily;\n    const fontWeight = node.style.fontWeight;\n    const fontSize = node.style.fontSize;\n    const textDecoration = node.style.textDecoration;\n\n    return {\n      ...originalOutput,\n      forChild: (lexicalNode, parent) => {\n        const originalForChild = originalOutput?.forChild ?? ((x) => x);\n        const result = originalForChild(lexicalNode, parent);\n        if ($isTextNode(result)) {\n          const style = [\n            backgroundColor ? `background-color: ${backgroundColor}` : null,\n            color ? `color: ${color}` : null,\n            fontFamily ? `font-family: ${fontFamily}` : null,\n            fontWeight ? `font-weight: ${fontWeight}` : null,\n            fontSize ? `font-size: ${fontSize}` : null,\n            textDecoration ? `text-decoration: ${textDecoration}` : null,\n          ]\n            .filter((value) => value != null)\n            .join('; ');\n          if (style.length) {\n            return result.setStyle(style);\n          }\n        }\n        return result;\n      }\n    };\n  };\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"json",children:"JSON"}),"\n",(0,i.jsx)(n.h3,{id:"lexical---json",children:"Lexical -> JSON"}),"\n",(0,i.jsxs)(n.p,{children:["To generate a JSON snapshot from an ",(0,i.jsx)(n.code,{children:"EditorState"}),", you can call the ",(0,i.jsx)(n.code,{children:"toJSON()"})," method on the ",(0,i.jsx)(n.code,{children:"EditorState"})," object."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const editorState = editor.getEditorState();\nconst json = editorState.toJSON();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, if you are trying to generate a stringified version of the ",(0,i.jsx)(n.code,{children:"EditorState"}),", you can simply using ",(0,i.jsx)(n.code,{children:"JSON.stringify"})," directly:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const editorState = editor.getEditorState();\nconst jsonString = JSON.stringify(editorState);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"lexicalnodeexportjson",children:(0,i.jsx)(n.code,{children:"LexicalNode.exportJSON()"})}),"\n",(0,i.jsxs)(n.p,{children:["You can control how a ",(0,i.jsx)(n.code,{children:"LexicalNode"})," is represented as JSON by adding an ",(0,i.jsx)(n.code,{children:"exportJSON()"})," method. It's important that you extend the serialization of the superclass by invoking ",(0,i.jsx)(n.code,{children:"super"}),": e.g. ",(0,i.jsx)(n.code,{children:"{ ...super.exportJSON(), /* your other properties */ }"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export type SerializedLexicalNode = {\n  type: string;\n  version: number;\n};\n\nexportJSON(): SerializedLexicalNode\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When transforming an editor state into JSON, we simply traverse the current editor state and call the ",(0,i.jsx)(n.code,{children:"exportJSON"})," method for each Node in order to convert it to a ",(0,i.jsx)(n.code,{children:"SerializedLexicalNode"})," object that represents the JSON object for the given node. The built-in nodes from Lexical already have a JSON representation defined, but you'll need to define ones for your own custom nodes."]}),"\n",(0,i.jsxs)(n.p,{children:["Here's an example of ",(0,i.jsx)(n.code,{children:"exportJSON"})," for the ",(0,i.jsx)(n.code,{children:"HeadingNode"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export type SerializedHeadingNode = Spread<\n  {\n    tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  },\n  SerializedElementNode\n>;\n\nexportJSON(): SerializedHeadingNode {\n  return {\n    ...super.exportJSON(),\n    tag: this.getTag(),\n  };\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"lexicalnodeimportjson",children:(0,i.jsx)(n.code,{children:"LexicalNode.importJSON()"})}),"\n",(0,i.jsxs)(n.p,{children:["You can control how a ",(0,i.jsx)(n.code,{children:"LexicalNode"})," is deserialized back into a node from JSON by adding an ",(0,i.jsx)(n.code,{children:"importJSON()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export type SerializedLexicalNode = {\n  type: string;\n  version: number;\n};\n\nimportJSON(jsonNode: SerializedLexicalNode): LexicalNode\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This method works in the opposite way to how ",(0,i.jsx)(n.code,{children:"exportJSON"})," works. Lexical uses the ",(0,i.jsx)(n.code,{children:"type"})," field on the JSON object to determine what Lexical node class it needs to map to, so keeping the ",(0,i.jsx)(n.code,{children:"type"})," field consistent with the ",(0,i.jsx)(n.code,{children:"getType()"})," of the LexicalNode is essential."]}),"\n",(0,i.jsxs)(n.p,{children:["You should use the ",(0,i.jsx)(n.code,{children:"updateFromJSON"})," method in your ",(0,i.jsx)(n.code,{children:"importJSON"})," to simplify the implementation and allow for future extension by the base classes."]}),"\n",(0,i.jsxs)(n.p,{children:["Here's an example of ",(0,i.jsx)(n.code,{children:"importJSON"})," for the ",(0,i.jsx)(n.code,{children:"HeadingNode"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"static importJSON(serializedNode: SerializedHeadingNode): HeadingNode {\n  return $createHeadingNode().updateFromJSON(serializedNode);\n}\n\nupdateFromJSON(\n  serializedNode: LexicalUpdateJSON<SerializedHeadingNode>,\n): this {\n  return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"lexicalnodeupdatefromjson",children:(0,i.jsx)(n.code,{children:"LexicalNode.updateFromJSON()"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"updateFromJSON"})," is a method introduced in Lexical 0.23 to simplify the implementation of ",(0,i.jsx)(n.code,{children:"importJSON"}),", so that a base class can expose the code that it is using to set all of the node's properties based on the JSON to any subclass."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["The input type used in this method is not sound in the general case, but it is safe if subclasses only add optional properties to the JSON. Even though it is not sound, the usage in this library is safe as long as your ",(0,i.jsx)(n.code,{children:"importJSON"})," method does not upcast the node before calling ",(0,i.jsx)(n.code,{children:"updateFromJSON"}),"."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export type SerializedExtendedTextNode = Spread<\n  // UNSAFE. This property is not optional\n  { newProperty: string },\n  SerializedTextNode\n>;\n"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export type SerializedExtendedTextNode = Spread<\n  // SAFE. This property is not optional\n  { newProperty?: string },\n  SerializedTextNode\n>;\n"})}),(0,i.jsx)(n.p,{children:"This is because it's possible to cast to a more general type, e.g."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const serializedNode: SerializedTextNode = { /* ... */ };\nconst newNode: TextNode = $createExtendedTextNode();\n// This passes the type check, but would fail at runtime if the updateFromJSON method required newProperty\nnewNode.updateFromJSON(serializedNode);\n"})})]}),"\n",(0,i.jsx)(n.h3,{id:"versioning--breaking-changes",children:"Versioning & Breaking Changes"}),"\n",(0,i.jsxs)(n.p,{children:["It's important to note that you should avoid making breaking changes to existing fields in your JSON object, especially if backwards compatibility is an important part of your editor. That's why we recommend using a version field to separate the different changes in your node as you add or change functionality of custom nodes. Here's the serialized type definition for Lexical's base ",(0,i.jsx)(n.code,{children:"TextNode"})," class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import type {Spread} from 'lexical';\n\n// Spread is a Typescript utility that allows us to spread the properties\n// over the base SerializedLexicalNode type.\nexport type SerializedTextNode = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n  },\n  SerializedLexicalNode\n>;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we wanted to make changes to the above ",(0,i.jsx)(n.code,{children:"TextNode"}),", we should be sure to not remove or change an existing property, as this can cause data corruption. Instead, opt to add the functionality as a new optional property field instead."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export type SerializedTextNode = Spread<\n  {\n    detail: number;\n    format: number;\n    mode: TextModeType;\n    style: string;\n    text: string;\n    // Our new field we've added\n    newField?: string,\n  },\n  SerializedLexicalNode\n>;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dangers-of-a-flat-version-property",children:"Dangers of a flat version property"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"updateFromJSON"})," method should ignore ",(0,i.jsx)(n.code,{children:"type"})," and ",(0,i.jsx)(n.code,{children:"version"}),", to support subclassing and code re-use. Ideally, you should only evolve your types in a backwards compatible way (new fields are optional), and/or have a uniquely named property to store the version in your class. Generally speaking, it's best if nearly all properties are optional and the node provides defaults for each property. This allows you to write less boilerplate code and produce smaller JSON."]}),"\n",(0,i.jsxs)(n.p,{children:["The reason that ",(0,i.jsx)(n.code,{children:"version"})," is no longer recommended is that it does not compose with subclasses. Consider this hierarchy:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class TextNode {\n  exportJSON() {\n    return { /* ... */, version: 1 };\n  }\n}\nclass ExtendedTextNode extends TextNode {\n  exportJSON() {\n    return { ...super.exportJSON() };\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"TextNode"})," is updated to ",(0,i.jsx)(n.code,{children:"version: 2"})," then this version and new serialization will propagate to ",(0,i.jsx)(n.code,{children:"ExtendedTextNode"})," via the ",(0,i.jsx)(n.code,{children:"super.exportJSON()"})," call, but this leaves nowhere to store a version for ",(0,i.jsx)(n.code,{children:"ExtendedTextNode"})," or vice versa. If the ",(0,i.jsx)(n.code,{children:"ExtendedTextNode"})," explicitly specified a ",(0,i.jsx)(n.code,{children:"version"}),", then the version of the base class will be ignored even though the representation of the JSON from the base class may change:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class TextNode {\n  exportJSON() {\n    return { /* ... */, version: 2 };\n  }\n}\nclass ExtendedTextNode extends TextNode {\n  exportJSON() {\n    // The super's layout has changed, but the version information is lost\n    return { ...super.exportJSON(), version: 1 };\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So then you have a situation where there are possibly two JSON layouts for ",(0,i.jsx)(n.code,{children:"ExtendedTextNode"})," with the same version, because the base class version changed due to a package upgrade."]}),"\n",(0,i.jsxs)(n.p,{children:["If you do have incompatible representations, it's probably best to choose a new type. This is basically the only way that will force old configurations to fail, as ",(0,i.jsx)(n.code,{children:"importJSON"})," implementations often don't do runtime validation and dangerously assume that the values are the correct type."]}),"\n",(0,i.jsx)(n.p,{children:"There are other schemes that would allow for composable versions, such as nesting the superclass data, or choosing a different name for a version property in each subclass. In practice, explicit versioning is generally redundant if the serialization is properly parsed, so it is recommended that you use the simpler approach with a flat representation with mostly optional properties."})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},22840:function(e,n,o){o.d(n,{Z:()=>d,a:()=>s});var t=o(2784);let i={},r=t.createContext(i);function s(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);