"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([["8846"],{43690:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>c,default:()=>h,contentTitle:()=>l,assets:()=>d,toc:()=>r,metadata:()=>i});var i=JSON.parse('{"id":"concepts/selection","title":"Selection","description":"Types of selection","source":"@site/docs/concepts/selection.md","sourceDirName":"concepts","slug":"/concepts/selection","permalink":"/docs/concepts/selection","draft":false,"unlisted":false,"editUrl":"https://github.com/QubitPi/lexical/tree/main/packages/lexical-website/docs/concepts/selection.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Commands","permalink":"/docs/concepts/commands"},"next":{"title":"Read Mode / Edit Mode","permalink":"/docs/concepts/read-only"}}'),o=t(52322),s=t(22840);let c={},l="Selection",d={},r=[{value:"Types of selection",id:"types-of-selection",level:2},{value:"<code>RangeSelection</code>",id:"rangeselection",level:3},{value:"<code>NodeSelection</code>",id:"nodeselection",level:3},{value:"<code>TableSelection</code>",id:"tableselection",level:3},{value:"<code>null</code>",id:"null",level:3},{value:"Working with selection",id:"working-with-selection",level:2},{value:"Focus",id:"focus",level:2}];function a(e){let n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"selection",children:"Selection"})}),"\n",(0,o.jsx)(n.h2,{id:"types-of-selection",children:"Types of selection"}),"\n",(0,o.jsxs)(n.p,{children:["Lexical's selection is part of the ",(0,o.jsx)(n.code,{children:"EditorState"}),". This means that for every update, or change to the editor, the\nselection always remains consistent with that of the ",(0,o.jsx)(n.code,{children:"EditorState"}),"'s node tree."]}),"\n",(0,o.jsx)(n.p,{children:"In Lexical, there are four types of selection possible:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"RangeSelection"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"NodeSelection"})}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"TableSelection"})," (implemented in ",(0,o.jsx)(n.code,{children:"@lexical/table"}),")"]}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"null"})}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["It is possible, but not generally recommended, to implement your own selection types that implement ",(0,o.jsx)(n.code,{children:"BaseSelection"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"rangeselection",children:(0,o.jsx)(n.code,{children:"RangeSelection"})}),"\n",(0,o.jsxs)(n.p,{children:["This is the most common type of selection, and is a normalization of the browser's DOM Selection and Range APIs.\n",(0,o.jsx)(n.code,{children:"RangeSelection"})," consists of three main properties:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"anchor"})," representing a ",(0,o.jsx)(n.code,{children:"RangeSelection"})," point"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"focus"})," representing a ",(0,o.jsx)(n.code,{children:"RangeSelection"})," point"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"format"})," numeric bitwise flag, representing any active text formats"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Both the ",(0,o.jsx)(n.code,{children:"anchor"})," and ",(0,o.jsx)(n.code,{children:"focus"})," points refer to an object that represents a specific part of the editor. The main properties of a ",(0,o.jsx)(n.code,{children:"RangeSelection"})," point are:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"key"})," representing the ",(0,o.jsx)(n.code,{children:"NodeKey"})," of the selected Lexical node"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"offset"})," representing the position from within its selected Lexical node. For the ",(0,o.jsx)(n.code,{children:"text"})," type this is the character, and for the ",(0,o.jsx)(n.code,{children:"element"})," type this is the child index from within the ",(0,o.jsx)(n.code,{children:"ElementNode"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"type"})," representing either ",(0,o.jsx)(n.code,{children:"element"})," or ",(0,o.jsx)(n.code,{children:"text"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"nodeselection",children:(0,o.jsx)(n.code,{children:"NodeSelection"})}),"\n",(0,o.jsx)(n.p,{children:"NodeSelection represents a selection of multiple arbitrary nodes. For example, three images selected at the same time."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"getNodes()"})," returns an array containing the selected LexicalNodes"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"tableselection",children:(0,o.jsx)(n.code,{children:"TableSelection"})}),"\n",(0,o.jsxs)(n.p,{children:["TableSelection represents a grid-like selection like tables. It stores the key of the parent node where the selection takes place and the start and end points.\n",(0,o.jsx)(n.code,{children:"TableSelection"})," consists of three main properties:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tableKey"})," representing the parent node key where the selection takes place"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"anchor"})," representing a ",(0,o.jsx)(n.code,{children:"TableSelection"})," point"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"focus"})," representing a ",(0,o.jsx)(n.code,{children:"TableSelection"})," point"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For example, a table where you select row = 1 col = 1 to row 2 col = 2 could be stored as follows:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tableKey = 2"})," table key"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"anchor = 4"})," table cell (key may vary)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"focus = 10"})," table cell (key may vary)"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Note that ",(0,o.jsx)(n.code,{children:"anchor"})," and ",(0,o.jsx)(n.code,{children:"focus"})," points work the same way as ",(0,o.jsx)(n.code,{children:"RangeSelection"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"null",children:(0,o.jsx)(n.code,{children:"null"})}),"\n",(0,o.jsx)(n.p,{children:"This is for when the editor doesn't have any active selection. This is common for when the editor has been blurred or when selection\nhas moved to another editor on the page. This can also happen when trying to select non-editable components within the editor space."}),"\n",(0,o.jsx)(n.h2,{id:"working-with-selection",children:"Working with selection"}),"\n",(0,o.jsxs)(n.p,{children:["Selection can be found using the ",(0,o.jsx)(n.code,{children:"$getSelection()"})," helper, exported from the ",(0,o.jsx)(n.code,{children:"lexical"})," package. This function can be used within\nan update, a read, or a command listener."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {$getSelection, SELECTION_CHANGE_COMMAND} from 'lexical';\n\neditor.update(() => {\n  const selection = $getSelection();\n});\n\neditorState.read(() => {\n  const selection = $getSelection();\n});\n\n// SELECTION_CHANGE_COMMAND fires when selection changes within a Lexical editor.\neditor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n  const selection = $getSelection();\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"In some cases you might want to create a new type of selection and set the editor selection to\nbe that. This can only be done in update or command listeners."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import {$setSelection, $createRangeSelection, $createNodeSelection} from \'lexical\';\n\neditor.update(() => {\n  // Set a range selection\n  const rangeSelection = $createRangeSelection();\n  $setSelection(rangeSelection);\n\n  // You can also indirectly create a range selection, by calling some of the selection\n  // methods on Lexical nodes.\n  const someNode = $getNodeByKey(someKey);\n\n  // On element nodes, this will create a RangeSelection with type "element",\n  // referencing an offset relating to the child within the element.\n  // On text nodes, this will create a RangeSelection with type "text",\n  // referencing the text character offset.\n  someNode.select();\n  someNode.selectPrevious();\n  someNode.selectNext();\n\n  // You can use this on any node.\n  someNode.selectStart();\n  someNode.selectEnd();\n\n  // Set a node selection\n  const nodeSelection = $createNodeSelection();\n  // Add a node key to the selection.\n  nodeSelection.add(someKey);\n  $setSelection(nodeSelection);\n\n  // You can also clear selection by setting it to `null`.\n  $setSelection(null);\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"focus",children:"Focus"}),"\n",(0,o.jsxs)(n.p,{children:["You may notice that when you issue an ",(0,o.jsx)(n.code,{children:"editor.update"})," or\n",(0,o.jsx)(n.code,{children:"editor.dispatchCommand"}),' then the editor can "steal focus" if there is\na selection and the editor is editable. This is because the Lexical\nselection is reconciled to the DOM selection during reconciliation,\nand the browser\'s focus follows its DOM selection.']}),"\n",(0,o.jsxs)(n.p,{children:["If you want to make updates or dispatch commands to the editor without\nchanging the selection, can use the ",(0,o.jsx)(n.code,{children:"SKIP_DOM_SELECTION_TAG"})," update tag\n(added in v0.22.0):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Call this from an editor.update or command listener\n$addUpdateTag(SKIP_DOM_SELECTION_TAG);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you want to add this tag during processing of a ",(0,o.jsx)(n.code,{children:"dispatchCommand"}),",\nyou can wrap it in an ",(0,o.jsx)(n.code,{children:"editor.update"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// NOTE: If you are already in a command listener or editor.update,\n//       do *not* nest a second editor.update! Nested updates have\n//       confusing semantics (dispatchCommand will re-use the\n//       current update without nesting)\neditor.update(() => {\n  $addUpdateTag(SKIP_DOM_SELECTION_TAG);\n  editor.dispatchCommand(/* \u2026 */);\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"If you have to support older versions of Lexical, you can mark the editor\nas not editable during the update or dispatch."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// NOTE: This code should be *outside* of your update or command listener, e.g.\n//       directly in the DOM event listener\nconst prevEditable = editor.isEditable();\neditor.setEditable(false);\neditor.update(\n  () => {\n    // run your update code or editor.dispatchCommand in here\n  }, {\n    onUpdate: () => {\n      editor.setEditable(prevEditable);\n    },\n  },\n);\n"})})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},22840:function(e,n,t){t.d(n,{Z:()=>l,a:()=>c});var i=t(2784);let o={},s=i.createContext(o);function c(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);